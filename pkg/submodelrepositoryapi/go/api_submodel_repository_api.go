// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * DotAAS Part 2 | HTTP/REST | Submodel Repository Service Specification
 *
 * The entire Submodel Repository Service Specification as part of the [Specification of the Asset Administration Shell: Part 2](http://industrialdigitaltwin.org/en/content-hub).   Publisher: Industrial Digital Twin Association (IDTA) 2023
 *
 * API version: V3.0.3_SSP-001
 * Contact: info@idtwin.org
 */

package openapi

import (
	"encoding/json"
	"io"
	"net/http"
	"os"
	"strings"

	"github.com/go-chi/chi/v5"
)

// SubmodelRepositoryAPIAPIController binds http requests to an api service and writes the service results to the http response
type SubmodelRepositoryAPIAPIController struct {
	service      SubmodelRepositoryAPIAPIServicer
	errorHandler ErrorHandler
}

// SubmodelRepositoryAPIAPIOption for how the controller is set up.
type SubmodelRepositoryAPIAPIOption func(*SubmodelRepositoryAPIAPIController)

// WithSubmodelRepositoryAPIAPIErrorHandler inject ErrorHandler into controller
func WithSubmodelRepositoryAPIAPIErrorHandler(h ErrorHandler) SubmodelRepositoryAPIAPIOption {
	return func(c *SubmodelRepositoryAPIAPIController) {
		c.errorHandler = h
	}
}

// NewSubmodelRepositoryAPIAPIController creates a default api controller
func NewSubmodelRepositoryAPIAPIController(s SubmodelRepositoryAPIAPIServicer, opts ...SubmodelRepositoryAPIAPIOption) *SubmodelRepositoryAPIAPIController {
	controller := &SubmodelRepositoryAPIAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the SubmodelRepositoryAPIAPIController
func (c *SubmodelRepositoryAPIAPIController) Routes() Routes {
	return Routes{
		"GetAllSubmodels": Route{
			strings.ToUpper("Get"),
			"/submodels",
			c.GetAllSubmodels,
		},
		"PostSubmodel": Route{
			strings.ToUpper("Post"),
			"/submodels",
			c.PostSubmodel,
		},
		"GetAllSubmodelsMetadata": Route{
			strings.ToUpper("Get"),
			"/submodels/$metadata",
			c.GetAllSubmodelsMetadata,
		},
		"GetAllSubmodelsValueOnly": Route{
			strings.ToUpper("Get"),
			"/submodels/$value",
			c.GetAllSubmodelsValueOnly,
		},
		"GetAllSubmodelsReference": Route{
			strings.ToUpper("Get"),
			"/submodels/$reference",
			c.GetAllSubmodelsReference,
		},
		"GetAllSubmodelsPath": Route{
			strings.ToUpper("Get"),
			"/submodels/$path",
			c.GetAllSubmodelsPath,
		},
		"GetSubmodelById": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}",
			c.GetSubmodelById,
		},
		"PutSubmodelById": Route{
			strings.ToUpper("Put"),
			"/submodels/{submodelIdentifier}",
			c.PutSubmodelById,
		},
		"DeleteSubmodelById": Route{
			strings.ToUpper("Delete"),
			"/submodels/{submodelIdentifier}",
			c.DeleteSubmodelById,
		},
		"PatchSubmodelById": Route{
			strings.ToUpper("Patch"),
			"/submodels/{submodelIdentifier}",
			c.PatchSubmodelById,
		},
		"GetSubmodelByIdMetadata": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/$metadata",
			c.GetSubmodelByIdMetadata,
		},
		"PatchSubmodelByIdMetadata": Route{
			strings.ToUpper("Patch"),
			"/submodels/{submodelIdentifier}/$metadata",
			c.PatchSubmodelByIdMetadata,
		},
		"GetSubmodelByIdValueOnly": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/$value",
			c.GetSubmodelByIdValueOnly,
		},
		"PatchSubmodelByIdValueOnly": Route{
			strings.ToUpper("Patch"),
			"/submodels/{submodelIdentifier}/$value",
			c.PatchSubmodelByIdValueOnly,
		},
		"GetSubmodelByIdReference": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/$reference",
			c.GetSubmodelByIdReference,
		},
		"GetSubmodelByIdPath": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/$path",
			c.GetSubmodelByIdPath,
		},
		"GetAllSubmodelElements": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements",
			c.GetAllSubmodelElements,
		},
		"PostSubmodelElementSubmodelRepo": Route{
			strings.ToUpper("Post"),
			"/submodels/{submodelIdentifier}/submodel-elements",
			c.PostSubmodelElementSubmodelRepo,
		},
		"GetAllSubmodelElementsMetadataSubmodelRepo": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/$metadata",
			c.GetAllSubmodelElementsMetadataSubmodelRepo,
		},
		"GetAllSubmodelElementsValueOnlySubmodelRepo": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/$value",
			c.GetAllSubmodelElementsValueOnlySubmodelRepo,
		},
		"GetAllSubmodelElementsReferenceSubmodelRepo": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/$reference",
			c.GetAllSubmodelElementsReferenceSubmodelRepo,
		},
		"GetAllSubmodelElementsPathSubmodelRepo": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/$path",
			c.GetAllSubmodelElementsPathSubmodelRepo,
		},
		"GetSubmodelElementByPathSubmodelRepo": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}",
			c.GetSubmodelElementByPathSubmodelRepo,
		},
		"PutSubmodelElementByPathSubmodelRepo": Route{
			strings.ToUpper("Put"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}",
			c.PutSubmodelElementByPathSubmodelRepo,
		},
		"PostSubmodelElementByPathSubmodelRepo": Route{
			strings.ToUpper("Post"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}",
			c.PostSubmodelElementByPathSubmodelRepo,
		},
		"DeleteSubmodelElementByPathSubmodelRepo": Route{
			strings.ToUpper("Delete"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}",
			c.DeleteSubmodelElementByPathSubmodelRepo,
		},
		"PatchSubmodelElementByPathSubmodelRepo": Route{
			strings.ToUpper("Patch"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}",
			c.PatchSubmodelElementByPathSubmodelRepo,
		},
		"GetSubmodelElementByPathMetadataSubmodelRepo": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$metadata",
			c.GetSubmodelElementByPathMetadataSubmodelRepo,
		},
		"PatchSubmodelElementByPathMetadataSubmodelRepo": Route{
			strings.ToUpper("Patch"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$metadata",
			c.PatchSubmodelElementByPathMetadataSubmodelRepo,
		},
		"GetSubmodelElementByPathValueOnlySubmodelRepo": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value",
			c.GetSubmodelElementByPathValueOnlySubmodelRepo,
		},
		"PatchSubmodelElementByPathValueOnlySubmodelRepo": Route{
			strings.ToUpper("Patch"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value",
			c.PatchSubmodelElementByPathValueOnlySubmodelRepo,
		},
		"GetSubmodelElementByPathReferenceSubmodelRepo": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$reference",
			c.GetSubmodelElementByPathReferenceSubmodelRepo,
		},
		"GetSubmodelElementByPathPathSubmodelRepo": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$path",
			c.GetSubmodelElementByPathPathSubmodelRepo,
		},
		"GetFileByPathSubmodelRepo": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment",
			c.GetFileByPathSubmodelRepo,
		},
		"PutFileByPathSubmodelRepo": Route{
			strings.ToUpper("Put"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment",
			c.PutFileByPathSubmodelRepo,
		},
		"DeleteFileByPathSubmodelRepo": Route{
			strings.ToUpper("Delete"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment",
			c.DeleteFileByPathSubmodelRepo,
		},
		"InvokeOperationSubmodelRepo": Route{
			strings.ToUpper("Post"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke",
			c.InvokeOperationSubmodelRepo,
		},
		"InvokeOperationValueOnly": Route{
			strings.ToUpper("Post"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke/$value",
			c.InvokeOperationValueOnly,
		},
		"InvokeOperationAsync": Route{
			strings.ToUpper("Post"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke-async",
			c.InvokeOperationAsync,
		},
		"InvokeOperationAsyncValueOnly": Route{
			strings.ToUpper("Post"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke-async/$value",
			c.InvokeOperationAsyncValueOnly,
		},
		"GetOperationAsyncStatus": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-status/{handleId}",
			c.GetOperationAsyncStatus,
		},
		"GetOperationAsyncResult": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-results/{handleId}",
			c.GetOperationAsyncResult,
		},
		"GetOperationAsyncResultValueOnly": Route{
			strings.ToUpper("Get"),
			"/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-results/{handleId}/$value",
			c.GetOperationAsyncResultValueOnly,
		},
	}
}

// GetAllSubmodels - Returns all Submodels
func (c *SubmodelRepositoryAPIAPIController) GetAllSubmodels(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var semanticIdParam string
	if query.Has("semanticId") {
		param := query.Get("semanticId")

		semanticIdParam = param
	} else {
	}
	var idShortParam string
	if query.Has("idShort") {
		param := query.Get("idShort")

		idShortParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var cursorParam string
	if query.Has("cursor") {
		param := query.Get("cursor")

		cursorParam = param
	} else {
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	var extentParam string
	if query.Has("extent") {
		param := query.Get("extent")

		extentParam = param
	} else {
		param := "withoutBlobValue"
		extentParam = param
	}
	result, err := c.service.GetAllSubmodels(r.Context(), semanticIdParam, idShortParam, limitParam, cursorParam, levelParam, extentParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PostSubmodel - Creates a new Submodel
func (c *SubmodelRepositoryAPIAPIController) PostSubmodel(w http.ResponseWriter, r *http.Request) {
	var submodelParam Submodel
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&submodelParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertSubmodelRequired(submodelParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertSubmodelConstraints(submodelParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PostSubmodel(r.Context(), submodelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAllSubmodelsMetadata - Returns the metadata attributes of all Submodels
func (c *SubmodelRepositoryAPIAPIController) GetAllSubmodelsMetadata(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var semanticIdParam string
	if query.Has("semanticId") {
		param := query.Get("semanticId")

		semanticIdParam = param
	} else {
	}
	var idShortParam string
	if query.Has("idShort") {
		param := query.Get("idShort")

		idShortParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var cursorParam string
	if query.Has("cursor") {
		param := query.Get("cursor")

		cursorParam = param
	} else {
	}
	result, err := c.service.GetAllSubmodelsMetadata(r.Context(), semanticIdParam, idShortParam, limitParam, cursorParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAllSubmodelsValueOnly - Returns all Submodels in their ValueOnly representation
func (c *SubmodelRepositoryAPIAPIController) GetAllSubmodelsValueOnly(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var semanticIdParam string
	if query.Has("semanticId") {
		param := query.Get("semanticId")

		semanticIdParam = param
	} else {
	}
	var idShortParam string
	if query.Has("idShort") {
		param := query.Get("idShort")

		idShortParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var cursorParam string
	if query.Has("cursor") {
		param := query.Get("cursor")

		cursorParam = param
	} else {
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	var extentParam string
	if query.Has("extent") {
		param := query.Get("extent")

		extentParam = param
	} else {
		param := "withoutBlobValue"
		extentParam = param
	}
	result, err := c.service.GetAllSubmodelsValueOnly(r.Context(), semanticIdParam, idShortParam, limitParam, cursorParam, levelParam, extentParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAllSubmodelsReference - Returns the References for all Submodels
func (c *SubmodelRepositoryAPIAPIController) GetAllSubmodelsReference(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var semanticIdParam string
	if query.Has("semanticId") {
		param := query.Get("semanticId")

		semanticIdParam = param
	} else {
	}
	var idShortParam string
	if query.Has("idShort") {
		param := query.Get("idShort")

		idShortParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var cursorParam string
	if query.Has("cursor") {
		param := query.Get("cursor")

		cursorParam = param
	} else {
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "core"
		levelParam = param
	}
	result, err := c.service.GetAllSubmodelsReference(r.Context(), semanticIdParam, idShortParam, limitParam, cursorParam, levelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAllSubmodelsPath - Returns all Submodels in the Path notation
func (c *SubmodelRepositoryAPIAPIController) GetAllSubmodelsPath(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var semanticIdParam string
	if query.Has("semanticId") {
		param := query.Get("semanticId")

		semanticIdParam = param
	} else {
	}
	var idShortParam string
	if query.Has("idShort") {
		param := query.Get("idShort")

		idShortParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var cursorParam string
	if query.Has("cursor") {
		param := query.Get("cursor")

		cursorParam = param
	} else {
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	result, err := c.service.GetAllSubmodelsPath(r.Context(), semanticIdParam, idShortParam, limitParam, cursorParam, levelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetSubmodelById - Returns a specific Submodel
func (c *SubmodelRepositoryAPIAPIController) GetSubmodelById(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	var extentParam string
	if query.Has("extent") {
		param := query.Get("extent")

		extentParam = param
	} else {
		param := "withoutBlobValue"
		extentParam = param
	}
	result, err := c.service.GetSubmodelById(r.Context(), submodelIdentifierParam, levelParam, extentParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PutSubmodelById - Updates an existing Submodel
func (c *SubmodelRepositoryAPIAPIController) PutSubmodelById(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var submodelParam Submodel
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&submodelParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertSubmodelRequired(submodelParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertSubmodelConstraints(submodelParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PutSubmodelById(r.Context(), submodelIdentifierParam, submodelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeleteSubmodelById - Deletes a Submodel
func (c *SubmodelRepositoryAPIAPIController) DeleteSubmodelById(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	result, err := c.service.DeleteSubmodelById(r.Context(), submodelIdentifierParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PatchSubmodelById - Updates an existing Submodel
func (c *SubmodelRepositoryAPIAPIController) PatchSubmodelById(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var submodelParam Submodel
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&submodelParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertSubmodelRequired(submodelParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertSubmodelConstraints(submodelParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "core"
		levelParam = param
	}
	result, err := c.service.PatchSubmodelById(r.Context(), submodelIdentifierParam, submodelParam, levelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetSubmodelByIdMetadata - Returns the metadata attributes of a specific Submodel
func (c *SubmodelRepositoryAPIAPIController) GetSubmodelByIdMetadata(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	result, err := c.service.GetSubmodelByIdMetadata(r.Context(), submodelIdentifierParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PatchSubmodelByIdMetadata - Updates the metadata attributes of an existing Submodel
func (c *SubmodelRepositoryAPIAPIController) PatchSubmodelByIdMetadata(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var submodelMetadataParam SubmodelMetadata
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&submodelMetadataParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertSubmodelMetadataRequired(submodelMetadataParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertSubmodelMetadataConstraints(submodelMetadataParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PatchSubmodelByIdMetadata(r.Context(), submodelIdentifierParam, submodelMetadataParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetSubmodelByIdValueOnly - Returns a specific Submodel in the ValueOnly representation
func (c *SubmodelRepositoryAPIAPIController) GetSubmodelByIdValueOnly(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	var extentParam string
	if query.Has("extent") {
		param := query.Get("extent")

		extentParam = param
	} else {
		param := "withoutBlobValue"
		extentParam = param
	}
	result, err := c.service.GetSubmodelByIdValueOnly(r.Context(), submodelIdentifierParam, levelParam, extentParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PatchSubmodelByIdValueOnly - Updates the values of an existing Submodel
func (c *SubmodelRepositoryAPIAPIController) PatchSubmodelByIdValueOnly(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var bodyParam map[string]interface{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&bodyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "core"
		levelParam = param
	}
	result, err := c.service.PatchSubmodelByIdValueOnly(r.Context(), submodelIdentifierParam, bodyParam, levelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetSubmodelByIdReference - Returns the Reference of a specific Submodel
func (c *SubmodelRepositoryAPIAPIController) GetSubmodelByIdReference(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	result, err := c.service.GetSubmodelByIdReference(r.Context(), submodelIdentifierParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetSubmodelByIdPath - Returns a specific Submodel in the Path notation
func (c *SubmodelRepositoryAPIAPIController) GetSubmodelByIdPath(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	result, err := c.service.GetSubmodelByIdPath(r.Context(), submodelIdentifierParam, levelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAllSubmodelElements - Returns all submodel elements including their hierarchy
func (c *SubmodelRepositoryAPIAPIController) GetAllSubmodelElements(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var cursorParam string
	if query.Has("cursor") {
		param := query.Get("cursor")

		cursorParam = param
	} else {
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	var extentParam string
	if query.Has("extent") {
		param := query.Get("extent")

		extentParam = param
	} else {
		param := "withoutBlobValue"
		extentParam = param
	}
	result, err := c.service.GetAllSubmodelElements(r.Context(), submodelIdentifierParam, limitParam, cursorParam, levelParam, extentParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PostSubmodelElementSubmodelRepo - Creates a new submodel element
func (c *SubmodelRepositoryAPIAPIController) PostSubmodelElementSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}

	// Read the raw JSON data from the request body
	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}

	// Use our custom factory function to create the appropriate concrete type
	submodelElementParam, err := UnmarshalSubmodelElement(bodyBytes)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}

	// FIXED: Use custom validation that handles optional references correctly
	if err := AssertSubmodelElementRequiredFixed(submodelElementParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertSubmodelElementConstraintsFixed(submodelElementParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PostSubmodelElementSubmodelRepo(r.Context(), submodelIdentifierParam, submodelElementParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAllSubmodelElementsMetadataSubmodelRepo - Returns the metadata attributes of all submodel elements including their hierarchy
func (c *SubmodelRepositoryAPIAPIController) GetAllSubmodelElementsMetadataSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var cursorParam string
	if query.Has("cursor") {
		param := query.Get("cursor")

		cursorParam = param
	} else {
	}
	result, err := c.service.GetAllSubmodelElementsMetadataSubmodelRepo(r.Context(), submodelIdentifierParam, limitParam, cursorParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAllSubmodelElementsValueOnlySubmodelRepo - Returns all submodel elements including their hierarchy in the ValueOnly representation
func (c *SubmodelRepositoryAPIAPIController) GetAllSubmodelElementsValueOnlySubmodelRepo(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var cursorParam string
	if query.Has("cursor") {
		param := query.Get("cursor")

		cursorParam = param
	} else {
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	var extentParam string
	if query.Has("extent") {
		param := query.Get("extent")

		extentParam = param
	} else {
		param := "withoutBlobValue"
		extentParam = param
	}
	result, err := c.service.GetAllSubmodelElementsValueOnlySubmodelRepo(r.Context(), submodelIdentifierParam, limitParam, cursorParam, levelParam, extentParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAllSubmodelElementsReferenceSubmodelRepo - Returns the References of all submodel elements
func (c *SubmodelRepositoryAPIAPIController) GetAllSubmodelElementsReferenceSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var cursorParam string
	if query.Has("cursor") {
		param := query.Get("cursor")

		cursorParam = param
	} else {
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "core"
		levelParam = param
	}
	result, err := c.service.GetAllSubmodelElementsReferenceSubmodelRepo(r.Context(), submodelIdentifierParam, limitParam, cursorParam, levelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetAllSubmodelElementsPathSubmodelRepo - Returns all submodel elements including their hierarchy in the Path notation
func (c *SubmodelRepositoryAPIAPIController) GetAllSubmodelElementsPathSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var cursorParam string
	if query.Has("cursor") {
		param := query.Get("cursor")

		cursorParam = param
	} else {
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	result, err := c.service.GetAllSubmodelElementsPathSubmodelRepo(r.Context(), submodelIdentifierParam, limitParam, cursorParam, levelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetSubmodelElementByPathSubmodelRepo - Returns a specific submodel element from the Submodel at a specified path
func (c *SubmodelRepositoryAPIAPIController) GetSubmodelElementByPathSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	var extentParam string
	if query.Has("extent") {
		param := query.Get("extent")

		extentParam = param
	} else {
		param := "withoutBlobValue"
		extentParam = param
	}
	result, err := c.service.GetSubmodelElementByPathSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam, levelParam, extentParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PutSubmodelElementByPathSubmodelRepo - Updates an existing submodel element at a specified path within submodel elements hierarchy
func (c *SubmodelRepositoryAPIAPIController) PutSubmodelElementByPathSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}

	// Read the raw JSON data from the request body
	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}

	// Use our custom factory function to create the appropriate concrete type
	submodelElementParam, err := UnmarshalSubmodelElement(bodyBytes)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertSubmodelElementRequired(submodelElementParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertSubmodelElementConstraints(submodelElementParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	result, err := c.service.PutSubmodelElementByPathSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam, submodelElementParam, levelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PostSubmodelElementByPathSubmodelRepo - Creates a new submodel element at a specified path within submodel elements hierarchy
func (c *SubmodelRepositoryAPIAPIController) PostSubmodelElementByPathSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}

	// Read the raw JSON data from the request body
	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}

	// Use our custom factory function to create the appropriate concrete type
	submodelElementParam, err := UnmarshalSubmodelElement(bodyBytes)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertSubmodelElementRequiredFixed(submodelElementParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertSubmodelElementConstraintsFixed(submodelElementParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PostSubmodelElementByPathSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam, submodelElementParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeleteSubmodelElementByPathSubmodelRepo - Deletes a submodel element at a specified path within the submodel elements hierarchy
func (c *SubmodelRepositoryAPIAPIController) DeleteSubmodelElementByPathSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	result, err := c.service.DeleteSubmodelElementByPathSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PatchSubmodelElementByPathSubmodelRepo - Updates an existing SubmodelElement
func (c *SubmodelRepositoryAPIAPIController) PatchSubmodelElementByPathSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}

	// Read the raw JSON data from the request body
	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}

	// Use our custom factory function to create the appropriate concrete type
	submodelElementParam, err := UnmarshalSubmodelElement(bodyBytes)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertSubmodelElementRequired(submodelElementParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertSubmodelElementConstraints(submodelElementParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "core"
		levelParam = param
	}
	result, err := c.service.PatchSubmodelElementByPathSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam, submodelElementParam, levelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetSubmodelElementByPathMetadataSubmodelRepo - Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
func (c *SubmodelRepositoryAPIAPIController) GetSubmodelElementByPathMetadataSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	result, err := c.service.GetSubmodelElementByPathMetadataSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PatchSubmodelElementByPathMetadataSubmodelRepo - Updates the metadata attributes an existing SubmodelElement
func (c *SubmodelRepositoryAPIAPIController) PatchSubmodelElementByPathMetadataSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	var submodelElementMetadataParam SubmodelElementMetadata
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&submodelElementMetadataParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertSubmodelElementMetadataRequired(submodelElementMetadataParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertSubmodelElementMetadataConstraints(submodelElementMetadataParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PatchSubmodelElementByPathMetadataSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam, submodelElementMetadataParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetSubmodelElementByPathValueOnlySubmodelRepo - Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
func (c *SubmodelRepositoryAPIAPIController) GetSubmodelElementByPathValueOnlySubmodelRepo(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	var extentParam string
	if query.Has("extent") {
		param := query.Get("extent")

		extentParam = param
	} else {
		param := "withoutBlobValue"
		extentParam = param
	}
	result, err := c.service.GetSubmodelElementByPathValueOnlySubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam, levelParam, extentParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PatchSubmodelElementByPathValueOnlySubmodelRepo - Updates the value of an existing SubmodelElement
func (c *SubmodelRepositoryAPIAPIController) PatchSubmodelElementByPathValueOnlySubmodelRepo(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	var submodelElementValueParam SubmodelElementValue
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&submodelElementValueParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertSubmodelElementValueRequired(submodelElementValueParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertSubmodelElementValueConstraints(submodelElementValueParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "core"
		levelParam = param
	}
	result, err := c.service.PatchSubmodelElementByPathValueOnlySubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam, submodelElementValueParam, levelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetSubmodelElementByPathReferenceSubmodelRepo - Returns the Referene of a specific submodel element from the Submodel at a specified path
func (c *SubmodelRepositoryAPIAPIController) GetSubmodelElementByPathReferenceSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	result, err := c.service.GetSubmodelElementByPathReferenceSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetSubmodelElementByPathPathSubmodelRepo - Returns a specific submodel element from the Submodel at a specified path in the Path notation
func (c *SubmodelRepositoryAPIAPIController) GetSubmodelElementByPathPathSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	var levelParam string
	if query.Has("level") {
		param := query.Get("level")

		levelParam = param
	} else {
		param := "deep"
		levelParam = param
	}
	result, err := c.service.GetSubmodelElementByPathPathSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam, levelParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetFileByPathSubmodelRepo - Downloads file content from a specific submodel element from the Submodel at a specified path
func (c *SubmodelRepositoryAPIAPIController) GetFileByPathSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	result, err := c.service.GetFileByPathSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// PutFileByPathSubmodelRepo - Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
func (c *SubmodelRepositoryAPIAPIController) PutFileByPathSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	if err := r.ParseMultipartForm(32 << 20); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}

	fileNameParam := r.FormValue("fileName")
	var fileParam *os.File
	{
		param, err := ReadFormFileToTempFile(r, "file")
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "file", Err: err}, nil)
			return
		}

		fileParam = param
	}

	result, err := c.service.PutFileByPathSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam, fileNameParam, fileParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeleteFileByPathSubmodelRepo - Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
func (c *SubmodelRepositoryAPIAPIController) DeleteFileByPathSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	result, err := c.service.DeleteFileByPathSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// InvokeOperationSubmodelRepo - Synchronously or asynchronously invokes an Operation at a specified path
func (c *SubmodelRepositoryAPIAPIController) InvokeOperationSubmodelRepo(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	var operationRequestParam OperationRequest
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&operationRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertOperationRequestRequired(operationRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertOperationRequestConstraints(operationRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	var asyncParam bool
	if query.Has("async") {
		param, err := parseBoolParameter(
			query.Get("async"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "async", Err: err}, nil)
			return
		}

		asyncParam = param
	} else {
		var param bool = false
		asyncParam = param
	}
	result, err := c.service.InvokeOperationSubmodelRepo(r.Context(), submodelIdentifierParam, idShortPathParam, operationRequestParam, asyncParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// InvokeOperationValueOnly - Synchronously or asynchronously invokes an Operation at a specified path
func (c *SubmodelRepositoryAPIAPIController) InvokeOperationValueOnly(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	aasIdentifierParam := chi.URLParam(r, "aasIdentifier")
	if aasIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"aasIdentifier"}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	var operationRequestValueOnlyParam OperationRequestValueOnly
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&operationRequestValueOnlyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertOperationRequestValueOnlyRequired(operationRequestValueOnlyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertOperationRequestValueOnlyConstraints(operationRequestValueOnlyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	var asyncParam bool
	if query.Has("async") {
		param, err := parseBoolParameter(
			query.Get("async"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "async", Err: err}, nil)
			return
		}

		asyncParam = param
	} else {
		var param bool = false
		asyncParam = param
	}
	result, err := c.service.InvokeOperationValueOnly(r.Context(), aasIdentifierParam, submodelIdentifierParam, idShortPathParam, operationRequestValueOnlyParam, asyncParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// InvokeOperationAsync - Asynchronously invokes an Operation at a specified path
func (c *SubmodelRepositoryAPIAPIController) InvokeOperationAsync(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	var operationRequestParam OperationRequest
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&operationRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertOperationRequestRequired(operationRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertOperationRequestConstraints(operationRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.InvokeOperationAsync(r.Context(), submodelIdentifierParam, idShortPathParam, operationRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// InvokeOperationAsyncValueOnly - Asynchronously invokes an Operation at a specified path
func (c *SubmodelRepositoryAPIAPIController) InvokeOperationAsyncValueOnly(w http.ResponseWriter, r *http.Request) {
	aasIdentifierParam := chi.URLParam(r, "aasIdentifier")
	if aasIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"aasIdentifier"}, nil)
		return
	}
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	var operationRequestValueOnlyParam OperationRequestValueOnly
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&operationRequestValueOnlyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertOperationRequestValueOnlyRequired(operationRequestValueOnlyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertOperationRequestValueOnlyConstraints(operationRequestValueOnlyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.InvokeOperationAsyncValueOnly(r.Context(), aasIdentifierParam, submodelIdentifierParam, idShortPathParam, operationRequestValueOnlyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetOperationAsyncStatus - Returns the status of an asynchronously invoked Operation
func (c *SubmodelRepositoryAPIAPIController) GetOperationAsyncStatus(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	handleIdParam := chi.URLParam(r, "handleId")
	if handleIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"handleId"}, nil)
		return
	}
	result, err := c.service.GetOperationAsyncStatus(r.Context(), submodelIdentifierParam, idShortPathParam, handleIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetOperationAsyncResult - Returns the Operation result of an asynchronously invoked Operation
func (c *SubmodelRepositoryAPIAPIController) GetOperationAsyncResult(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	handleIdParam := chi.URLParam(r, "handleId")
	if handleIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"handleId"}, nil)
		return
	}
	result, err := c.service.GetOperationAsyncResult(r.Context(), submodelIdentifierParam, idShortPathParam, handleIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetOperationAsyncResultValueOnly - Returns the Operation result of an asynchronously invoked Operation
func (c *SubmodelRepositoryAPIAPIController) GetOperationAsyncResultValueOnly(w http.ResponseWriter, r *http.Request) {
	submodelIdentifierParam := chi.URLParam(r, "submodelIdentifier")
	if submodelIdentifierParam == "" {
		c.errorHandler(w, r, &RequiredError{"submodelIdentifier"}, nil)
		return
	}
	idShortPathParam := chi.URLParam(r, "idShortPath")
	if idShortPathParam == "" {
		c.errorHandler(w, r, &RequiredError{"idShortPath"}, nil)
		return
	}
	handleIdParam := chi.URLParam(r, "handleId")
	if handleIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"handleId"}, nil)
		return
	}
	result, err := c.service.GetOperationAsyncResultValueOnly(r.Context(), submodelIdentifierParam, idShortPathParam, handleIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
