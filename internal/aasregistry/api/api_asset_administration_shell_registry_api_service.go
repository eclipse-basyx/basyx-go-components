// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * DotAAS Part 2 | HTTP/REST | Asset Administration Shell Registry Service Specification
 *
 * The Full Profile of the Asset Administration Shell Registry Service Specification as part of the [Specification of the Asset Administration Shell: Part 2](https://industrialdigitaltwin.org/en/content-hub/aasspecifications).   Copyright: Industrial Digital Twin Association (IDTA) 2025
 *
 * API version: V3.1.1_SSP-001
 * Contact: info@idtwin.org
 */

package ass_registry_api

import (
    "context"
    "errors"
    "net/http"
    "strings"

	persistence_postgresql "github.com/eclipse-basyx/basyx-go-components/internal/aasregistry/persistence"
	"github.com/eclipse-basyx/basyx-go-components/internal/common"
	"github.com/eclipse-basyx/basyx-go-components/internal/common/model"
)

const (
	componentName = "AASR"
)

// AssetAdministrationShellRegistryAPIAPIService is a service that implements the logic for the AssetAdministrationShellRegistryAPIAPIServicer
// This service should implement the business logic for every endpoint for the AssetAdministrationShellRegistryAPIAPI API.
// Include any external packages or services that will be required by this service.
type AssetAdministrationShellRegistryAPIAPIService struct {
	aasRegistryBackend persistence_postgresql.PostgreSQLAASRegistryDatabase
}

// NewAssetAdministrationShellRegistryAPIAPIService creates a default api service
func NewAssetAdministrationShellRegistryAPIAPIService(databaseBackend persistence_postgresql.PostgreSQLAASRegistryDatabase) *AssetAdministrationShellRegistryAPIAPIService {
	return &AssetAdministrationShellRegistryAPIAPIService{
		aasRegistryBackend: databaseBackend,
	}
}

// GetAllAssetAdministrationShellDescriptors - Returns all Asset Administration Shell Descriptors
func (s *AssetAdministrationShellRegistryAPIAPIService) GetAllAssetAdministrationShellDescriptors(ctx context.Context, limit int32, cursor string, assetKind model.AssetKind, assetType string) (model.ImplResponse, error) {
	// TODO - update GetAllAssetAdministrationShellDescriptors with the required logic for this service method.
	// Add api_asset_administration_shell_registry_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, GetAssetAdministrationShellDescriptorsResult{}) or use other options such as http.Ok ...
	// return Response(200, GetAssetAdministrationShellDescriptorsResult{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return Response(0, Result{}), nil

	var internalCursor string
	if strings.TrimSpace(cursor) != "" {
		dec, decErr := common.DecodeString(cursor)
		if decErr != nil {
			return common.NewErrorResponse(
				decErr, http.StatusBadRequest, componentName, "GetAllAssetAdministrationShellDescriptors", "BadCursor",
			), nil
		}
		internalCursor = dec
	}
	aasds, nextCursor, err := s.aasRegistryBackend.ListAssetAdministrationShellDescriptors(ctx, limit, internalCursor, assetKind, assetType)
	if err != nil {
		return common.NewErrorResponse(
			err, http.StatusInternalServerError, componentName, "GetAllAssetAdministrationShellDescriptors", "InternalServerError",
		), err
	}

	pm := model.PagedResultPagingMetadata{}
	if nextCursor != "" {
		pm.Cursor = common.EncodeString(nextCursor)
	}
	res := interface{}(struct {
		PagingMetadata interface{}
		Result         interface{}
	}{
		PagingMetadata: pm,
		Result:         aasds,
	})
	return model.Response(http.StatusOK, res), nil
}

// PostAssetAdministrationShellDescriptor - Creates a new Asset Administration Shell Descriptor, i.e. registers an AAS
func (s *AssetAdministrationShellRegistryAPIAPIService) PostAssetAdministrationShellDescriptor(ctx context.Context, assetAdministrationShellDescriptor model.AssetAdministrationShellDescriptor) (model.ImplResponse, error) {
	// TODO - update PostAssetAdministrationShellDescriptor with the required logic for this service method.
	// Add api_asset_administration_shell_registry_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(201, AssetAdministrationShellDescriptor{}) or use other options such as http.Ok ...
	// return Response(201, AssetAdministrationShellDescriptor{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(409, Result{}) or use other options such as http.Ok ...
	// return Response(409, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return Response(0, Result{}), nil

	// Existence check: AAS with same Id should not already exist (lightweight)
	if strings.TrimSpace(assetAdministrationShellDescriptor.Id) != "" {
		if exists, chkErr := s.aasRegistryBackend.ExistsAASByID(ctx, assetAdministrationShellDescriptor.Id); chkErr != nil {
			return common.NewErrorResponse(
				chkErr, http.StatusInternalServerError, componentName, "PostAssetAdministrationShellDescriptor", "Unhandled-Precheck",
			), chkErr
		} else if exists {
			return common.NewErrorResponse(
				common.NewErrConflict("AAS with given id already exists"), http.StatusConflict, componentName, "PostAssetAdministrationShellDescriptor", "Conflict-Exists",
			), nil
		}
	}

	err := s.aasRegistryBackend.InsertAdministrationShellDescriptor(ctx, assetAdministrationShellDescriptor)
	if err != nil {
		switch {
		case common.IsErrBadRequest(err):
			return common.NewErrorResponse(
				err, http.StatusBadRequest, componentName, "InsertAdministrationShellDescriptor", "BadRequest",
			), nil
		case common.IsErrConflict(err):
			return common.NewErrorResponse(
				err, http.StatusConflict, componentName, "InsertAdministrationShellDescriptor", "Conflict",
			), nil
		default:
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "InsertAdministrationShellDescriptor", "Unhandled",
			), err
		}
	}

	return model.Response(http.StatusCreated, assetAdministrationShellDescriptor), nil
}

// GetAssetAdministrationShellDescriptorById - Returns a specific Asset Administration Shell Descriptor
func (s *AssetAdministrationShellRegistryAPIAPIService) GetAssetAdministrationShellDescriptorById(ctx context.Context, aasIdentifier string) (model.ImplResponse, error) {
	// TODO - update GetAssetAdministrationShellDescriptorById with the required logic for this service method.
	// Add api_asset_administration_shell_registry_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, AssetAdministrationShellDescriptor{}) or use other options such as http.Ok ...
	// return Response(200, AssetAdministrationShellDescriptor{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return Response(0, Result{}), nil

	decoded, decodeErr := common.DecodeString(aasIdentifier)
	if decodeErr != nil {
		return common.NewErrorResponse(
			decodeErr, http.StatusBadRequest, componentName, "GetAssetAdministrationShellDescriptorById", "BadRequest-Decode",
		), nil
	}

	result, err := s.aasRegistryBackend.GetAssetAdministrationShellDescriptorById(ctx, string(decoded))
	if err != nil {
		switch {
		case common.IsErrNotFound(err):
			return common.NewErrorResponse(
				err, http.StatusNotFound, componentName, "GetAssetAdministrationShellDescriptorById", "NotFound",
			), nil
		default:
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "GetAssetAdministrationShellDescriptorById", "Unhandled",
			), err
		}
	}

	return model.Response(http.StatusOK, result), nil
}

// PutAssetAdministrationShellDescriptorById - Creates or updates an existing Asset Administration Shell Descriptor
func (s *AssetAdministrationShellRegistryAPIAPIService) PutAssetAdministrationShellDescriptorById(ctx context.Context, aasIdentifier string, assetAdministrationShellDescriptor model.AssetAdministrationShellDescriptor) (model.ImplResponse, error) {
	// Decode path AAS id
	decodedAAS, decErr := common.DecodeString(aasIdentifier)
	if decErr != nil {
		return common.NewErrorResponse(
			decErr, http.StatusBadRequest, componentName, "PutAssetAdministrationShellDescriptorById", "BadRequest-Decode",
		), nil
	}

	// Enforce id consistency with path
	if strings.TrimSpace(assetAdministrationShellDescriptor.Id) != "" && assetAdministrationShellDescriptor.Id != decodedAAS {
		return common.NewErrorResponse(
			errors.New("body id does not match path id"), http.StatusBadRequest, componentName, "PutAssetAdministrationShellDescriptorById", "BadRequest-IdMismatch",
		), nil
	}
	assetAdministrationShellDescriptor.Id = decodedAAS

    existed, err := s.aasRegistryBackend.ReplaceAdministrationShellDescriptor(ctx, assetAdministrationShellDescriptor)
    if err != nil {
        switch {
        case common.IsErrBadRequest(err):
            return common.NewErrorResponse(
                err, http.StatusBadRequest, componentName, "PutAssetAdministrationShellDescriptorById", "BadRequest",
            ), nil
        case common.IsErrConflict(err):
            return common.NewErrorResponse(
                err, http.StatusConflict, componentName, "PutAssetAdministrationShellDescriptorById", "Conflict",
            ), nil
        default:
            return common.NewErrorResponse(
                err, http.StatusInternalServerError, componentName, "PutAssetAdministrationShellDescriptorById", "Unhandled-Insert",
            ), err
        }
    }

    if existed {
        return model.Response(http.StatusNoContent, nil), nil
    }
    return model.Response(http.StatusCreated, assetAdministrationShellDescriptor), nil
}

// DeleteAssetAdministrationShellDescriptorById - Deletes an Asset Administration Shell Descriptor, i.e. de-registers an AAS
func (s *AssetAdministrationShellRegistryAPIAPIService) DeleteAssetAdministrationShellDescriptorById(ctx context.Context, aasIdentifier string) (model.ImplResponse, error) {
	decoded, decodeErr := common.DecodeString(aasIdentifier)
	if decodeErr != nil {
		return common.NewErrorResponse(
			decodeErr, http.StatusBadRequest, componentName, "DeleteAssetAdministrationShellDescriptorById", "BadRequest-Decode",
		), nil
	}

	if err := s.aasRegistryBackend.DeleteAssetAdministrationShellDescriptorById(ctx, decoded); err != nil {
		switch {
		case common.IsErrNotFound(err):
			return common.NewErrorResponse(
				err, http.StatusNotFound, componentName, "DeleteAssetAdministrationShellDescriptorById", "NotFound",
			), nil
		case common.IsErrBadRequest(err):
			return common.NewErrorResponse(
				err, http.StatusBadRequest, componentName, "DeleteAssetAdministrationShellDescriptorById", "BadRequest",
			), nil
		default:
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "DeleteAssetAdministrationShellDescriptorById", "Unhandled",
			), err
		}
	}

	return model.Response(http.StatusNoContent, nil), nil
}

// GetAllSubmodelDescriptorsThroughSuperpath - Returns all Submodel Descriptors
func (s *AssetAdministrationShellRegistryAPIAPIService) GetAllSubmodelDescriptorsThroughSuperpath(ctx context.Context, aasIdentifier string, limit int32, cursor string) (model.ImplResponse, error) {
	// Decode AAS identifier from path
	decodedAAS, decodeErr := common.DecodeString(aasIdentifier)
	if decodeErr != nil {
		return common.NewErrorResponse(
			decodeErr, http.StatusBadRequest, componentName, "GetAllSubmodelDescriptorsThroughSuperpath", "BadRequest-Decode",
		), nil
	}

	// Check AAS existence
	if exists, chkErr := s.aasRegistryBackend.ExistsAASByID(ctx, decodedAAS); chkErr != nil {
		return common.NewErrorResponse(
			chkErr, http.StatusInternalServerError, componentName, "GetAllSubmodelDescriptorsThroughSuperpath", "Unhandled-ExistenceCheck",
		), chkErr
	} else if !exists {
		return common.NewErrorResponse(
			common.NewErrNotFound("AAS not found"), http.StatusNotFound, componentName, "GetAllSubmodelDescriptorsThroughSuperpath", "NotFound",
		), nil
	}

	// Decode cursor if provided
	var internalCursor string
	if strings.TrimSpace(cursor) != "" {
		dec, decErr := common.DecodeString(cursor)
		if decErr != nil {
			return common.NewErrorResponse(
				decErr, http.StatusBadRequest, componentName, "GetAllSubmodelDescriptorsThroughSuperpath", "BadCursor",
			), nil
		}
		internalCursor = dec
	}

	// Read submodel descriptors via persistence layer
	smds, nextCursor, err := s.aasRegistryBackend.ListSubmodelDescriptorsForAAS(ctx, decodedAAS, limit, internalCursor)
	if err != nil {
		return common.NewErrorResponse(
			err, http.StatusInternalServerError, componentName, "GetAllSubmodelDescriptorsThroughSuperpath", "InternalServerError",
		), err
	}

	// Paging metadata and response envelope
	pm := model.PagedResultPagingMetadata{}
	if nextCursor != "" {
		pm.Cursor = common.EncodeString(nextCursor)
	}
	res := interface{}(struct {
		PagingMetadata interface{}
		Result         interface{}
	}{
		PagingMetadata: pm,
		Result:         smds,
	})
	return model.Response(http.StatusOK, res), nil
}

// PostSubmodelDescriptorThroughSuperpath - Creates a new Submodel Descriptor, i.e. registers a submodel
func (s *AssetAdministrationShellRegistryAPIAPIService) PostSubmodelDescriptorThroughSuperpath(ctx context.Context, aasIdentifier string, submodelDescriptor model.SubmodelDescriptor) (model.ImplResponse, error) {
	// Decode AAS identifier from path
	decodedAAS, decodeErr := common.DecodeString(aasIdentifier)
	if decodeErr != nil {
		return common.NewErrorResponse(
			decodeErr, http.StatusBadRequest, componentName, "PostSubmodelDescriptorThroughSuperpath", "BadRequest-Decode",
		), nil
	}

	// Conflict check: lightweight existence for submodel under this AAS
	if strings.TrimSpace(submodelDescriptor.Id) != "" {
		if exists, chkErr := s.aasRegistryBackend.ExistsSubmodelForAAS(ctx, decodedAAS, submodelDescriptor.Id); chkErr != nil {
			return common.NewErrorResponse(
				chkErr, http.StatusInternalServerError, componentName, "PostSubmodelDescriptorThroughSuperpath", "Unhandled-Precheck",
			), chkErr
		} else if exists {
			return common.NewErrorResponse(
				common.NewErrConflict("Submodel with given id already exists for this AAS"), http.StatusConflict, componentName, "PostSubmodelDescriptorThroughSuperpath", "Conflict-Exists",
			), nil
		}
	}

	// Persist submodel descriptor under the AAS
	if err := s.aasRegistryBackend.InsertSubmodelDescriptorForAAS(ctx, decodedAAS, submodelDescriptor); err != nil {
		switch {
		case common.IsErrNotFound(err):
			return common.NewErrorResponse(
				err, http.StatusNotFound, componentName, "PostSubmodelDescriptorThroughSuperpath", "NotFound",
			), nil
		case common.IsErrBadRequest(err):
			return common.NewErrorResponse(
				err, http.StatusBadRequest, componentName, "PostSubmodelDescriptorThroughSuperpath", "BadRequest",
			), nil
		case common.IsErrConflict(err):
			return common.NewErrorResponse(
				err, http.StatusConflict, componentName, "PostSubmodelDescriptorThroughSuperpath", "Conflict",
			), nil
		default:
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "PostSubmodelDescriptorThroughSuperpath", "Unhandled",
			), err
		}
	}

	return model.Response(http.StatusCreated, submodelDescriptor), nil
}

// GetSubmodelDescriptorByIdThroughSuperpath - Returns a specific Submodel Descriptor
func (s *AssetAdministrationShellRegistryAPIAPIService) GetSubmodelDescriptorByIdThroughSuperpath(ctx context.Context, aasIdentifier string, submodelIdentifier string) (model.ImplResponse, error) {
	// Decode path params
	decodedAAS, decErr := common.DecodeString(aasIdentifier)
	if decErr != nil {
		return common.NewErrorResponse(
			decErr, http.StatusBadRequest, componentName, "GetSubmodelDescriptorByIdThroughSuperpath", "BadRequest-Decode-AAS",
		), nil
	}
	decodedSMD, decErr2 := common.DecodeString(submodelIdentifier)
	if decErr2 != nil {
		return common.NewErrorResponse(
			decErr2, http.StatusBadRequest, componentName, "GetSubmodelDescriptorByIdThroughSuperpath", "BadRequest-Decode-Submodel",
		), nil
	}

	smd, err := s.aasRegistryBackend.GetSubmodelDescriptorForAASByID(ctx, decodedAAS, decodedSMD)
	if err != nil {
		switch {
		case common.IsErrNotFound(err):
			return common.NewErrorResponse(
				err, http.StatusNotFound, componentName, "GetSubmodelDescriptorByIdThroughSuperpath", "NotFound",
			), nil
		default:
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "GetSubmodelDescriptorByIdThroughSuperpath", "Unhandled",
			), err
		}
	}

	return model.Response(http.StatusOK, smd), nil
}

// PutSubmodelDescriptorByIdThroughSuperpath - Creates or updates an existing Submodel Descriptor
func (s *AssetAdministrationShellRegistryAPIAPIService) PutSubmodelDescriptorByIdThroughSuperpath(ctx context.Context, aasIdentifier string, submodelIdentifier string, submodelDescriptor model.SubmodelDescriptor) (model.ImplResponse, error) {
	// Decode path params
	decodedAAS, decErr := common.DecodeString(aasIdentifier)
	if decErr != nil {
		return common.NewErrorResponse(
			decErr, http.StatusBadRequest, componentName, "PutSubmodelDescriptorByIdThroughSuperpath", "BadRequest-Decode-AAS",
		), nil
	}
	decodedSMD, decErr2 := common.DecodeString(submodelIdentifier)
	if decErr2 != nil {
		return common.NewErrorResponse(
			decErr2, http.StatusBadRequest, componentName, "PutSubmodelDescriptorByIdThroughSuperpath", "BadRequest-Decode-Submodel",
		), nil
	}

	// Enforce id consistency
	if strings.TrimSpace(submodelDescriptor.Id) != "" && submodelDescriptor.Id != decodedSMD {
		return common.NewErrorResponse(
			errors.New("body id does not match path id"), http.StatusBadRequest, componentName, "PutSubmodelDescriptorByIdThroughSuperpath", "BadRequest-IdMismatch",
		), nil
	}
	submodelDescriptor.Id = decodedSMD

	// Determine existence
	_, getErr := s.aasRegistryBackend.GetSubmodelDescriptorForAASByID(ctx, decodedAAS, decodedSMD)
	exists := getErr == nil

	if exists {
		if err := s.aasRegistryBackend.DeleteSubmodelDescriptorForAASByID(ctx, decodedAAS, decodedSMD); err != nil {
			switch {
			case common.IsErrNotFound(err):
				// fall through
			case common.IsErrBadRequest(err):
				return common.NewErrorResponse(
					err, http.StatusBadRequest, componentName, "PutSubmodelDescriptorByIdThroughSuperpath", "BadRequest",
				), nil
			default:
				return common.NewErrorResponse(
					err, http.StatusInternalServerError, componentName, "PutSubmodelDescriptorByIdThroughSuperpath", "Unhandled-Delete",
				), err
			}
		}
	}

	if err := s.aasRegistryBackend.InsertSubmodelDescriptorForAAS(ctx, decodedAAS, submodelDescriptor); err != nil {
		switch {
		case common.IsErrNotFound(err):
			return common.NewErrorResponse(
				err, http.StatusNotFound, componentName, "PutSubmodelDescriptorByIdThroughSuperpath", "NotFound",
			), nil
		case common.IsErrBadRequest(err):
			return common.NewErrorResponse(
				err, http.StatusBadRequest, componentName, "PutSubmodelDescriptorByIdThroughSuperpath", "BadRequest",
			), nil
		case common.IsErrConflict(err):
			return common.NewErrorResponse(
				err, http.StatusConflict, componentName, "PutSubmodelDescriptorByIdThroughSuperpath", "Conflict",
			), nil
		default:
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "PutSubmodelDescriptorByIdThroughSuperpath", "Unhandled-Insert",
			), err
		}
	}

	if exists {
		return model.Response(http.StatusNoContent, nil), nil
	}
	return model.Response(http.StatusCreated, submodelDescriptor), nil
}

// DeleteSubmodelDescriptorByIdThroughSuperpath - Deletes a Submodel Descriptor, i.e. de-registers a submodel
func (s *AssetAdministrationShellRegistryAPIAPIService) DeleteSubmodelDescriptorByIdThroughSuperpath(ctx context.Context, aasIdentifier string, submodelIdentifier string) (model.ImplResponse, error) {
	decodedAAS, decErr := common.DecodeString(aasIdentifier)
	if decErr != nil {
		return common.NewErrorResponse(
			decErr, http.StatusBadRequest, componentName, "DeleteSubmodelDescriptorByIdThroughSuperpath", "BadRequest-Decode-AAS",
		), nil
	}
	decodedSMD, decErr2 := common.DecodeString(submodelIdentifier)
	if decErr2 != nil {
		return common.NewErrorResponse(
			decErr2, http.StatusBadRequest, componentName, "DeleteSubmodelDescriptorByIdThroughSuperpath", "BadRequest-Decode-Submodel",
		), nil
	}

	if err := s.aasRegistryBackend.DeleteSubmodelDescriptorForAASByID(ctx, decodedAAS, decodedSMD); err != nil {
		switch {
		case common.IsErrNotFound(err):
			return common.NewErrorResponse(
				err, http.StatusNotFound, componentName, "DeleteSubmodelDescriptorByIdThroughSuperpath", "NotFound",
			), nil
		case common.IsErrBadRequest(err):
			return common.NewErrorResponse(
				err, http.StatusBadRequest, componentName, "DeleteSubmodelDescriptorByIdThroughSuperpath", "BadRequest",
			), nil
		default:
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "DeleteSubmodelDescriptorByIdThroughSuperpath", "Unhandled",
			), err
		}
	}
	return model.Response(http.StatusNoContent, nil), nil
}
