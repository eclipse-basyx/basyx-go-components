// Code generated by OpenAPI Generator (https://openapi-generator.tech);

/*
 * DotAAS Part 2 | HTTP/REST | Submodel Repository Service Specification
 *
 * The entire Submodel Repository Service Specification as part of the [Specification of the Asset Administration Shell: Part 2](http://industrialdigitaltwin.org/en/content-hub).   Publisher: Industrial Digital Twin Association (IDTA) 2023
 *
 * API version: V3.0.3_SSP-001
 * Contact: info@idtwin.org
 */

// Package api for the SubmodelRepositoryAPIAPI service
package api

import (
	"context"
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"os"

	"github.com/FriedJannik/aas-go-sdk/jsonization"
	"github.com/FriedJannik/aas-go-sdk/types"
	"github.com/eclipse-basyx/basyx-go-components/internal/common"
	gen "github.com/eclipse-basyx/basyx-go-components/internal/common/model"
	"github.com/eclipse-basyx/basyx-go-components/internal/common/model/grammar"
	persistencepostgresql "github.com/eclipse-basyx/basyx-go-components/internal/submodelrepository/persistence"
	openapi "github.com/eclipse-basyx/basyx-go-components/pkg/submodelrepositoryapi/go"
)

// SubmodelRepositoryAPIAPIService is a service that implements the logic for the SubmodelRepositoryAPIAPIServicer
// This service should implement the business logic for every endpoint for the SubmodelRepositoryAPIAPI API.
// Include any external packages or services that will be required by this service.
type SubmodelRepositoryAPIAPIService struct {
	submodelBackend persistencepostgresql.SubmodelDatabase
}

// NewSubmodelRepositoryAPIAPIService creates a default api service
func NewSubmodelRepositoryAPIAPIService(databaseBackend persistencepostgresql.SubmodelDatabase) *SubmodelRepositoryAPIAPIService {
	return &SubmodelRepositoryAPIAPIService{
		submodelBackend: databaseBackend,
	}
}

func submodelValueToAnyMap(value gen.SubmodelValue) map[string]any {
	result := make(map[string]any, len(value))
	for key, val := range value {
		result[key] = val
	}
	return result
}

func decodeBase64RawStd(value string) (string, error) {
	if value == "" {
		return "", nil
	}

	decodedBytes, err := base64.RawStdEncoding.DecodeString(value)
	if err != nil {
		return "", err
	}

	return string(decodedBytes), nil
}

func encodeBase64RawStd(value string) string {
	if value == "" {
		return ""
	}

	return base64.RawStdEncoding.EncodeToString([]byte(value))
}

func buildLimitPtr(limit int32) *int {
	if limit <= 0 {
		return nil
	}

	parsedLimit := int(limit)
	return &parsedLimit
}

func toSubmodelElementMetadata(element types.ISubmodelElement) (gen.SubmodelElementMetadata, error) {
	jsonElement, err := jsonization.ToJsonable(element)
	if err != nil {
		return gen.SubmodelElementMetadata{}, err
	}

	payload, err := json.Marshal(jsonElement)
	if err != nil {
		return gen.SubmodelElementMetadata{}, err
	}

	metadata := gen.SubmodelElementMetadata{}
	if err := json.Unmarshal(payload, &metadata); err != nil {
		return gen.SubmodelElementMetadata{}, err
	}

	return metadata, nil
}

func getModelTypeLiteral(element types.ISubmodelElement) string {
	jsonElement, err := jsonization.ToJsonable(element)
	if err != nil {
		return ""
	}

	modelType, ok := jsonElement["modelType"].(string)
	if !ok {
		return ""
	}

	return modelType
}

func buildModelReference(submodelID string, keyType string, keyValue string) (types.IReference, error) {
	if submodelID == "" || keyType == "" || keyValue == "" {
		return nil, common.NewErrBadRequest("SMREPO-BUILDREF-INVALIDPARAMS Invalid reference parameters")
	}

	jsonableReference := map[string]any{
		"type": "ModelReference",
		"keys": []map[string]any{
			{
				"type":  "Submodel",
				"value": submodelID,
			},
			{
				"type":  keyType,
				"value": keyValue,
			},
		},
	}

	return jsonization.ReferenceFromJsonable(jsonableReference)
}

// GetAllSubmodels retrieves all submodels from the repository with optional filtering and pagination.
// It supports filtering by idShort and provides pagination through cursor-based navigation.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - semanticID: Semantic identifier for filtering (currently unused)
//   - idShort: Short identifier for filtering submodels
//   - limit: Maximum number of submodels to return
//   - cursor: Pagination cursor for continuing from previous results
//   - level: Detail level for response (currently unused)
//   - extent: Response extent specification (currently unused)
//
// Returns:
//   - gen.ImplResponse: Response containing paginated submodel results
//   - error: Error if the operation fails
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodels(
	_ /*ctx*/ context.Context,
	_ /*semanticID*/ string,
	idShort string,
	limit int32,
	cursor string,
	_ /*level*/ string,
	_ /*extent*/ string,
) (gen.ImplResponse, error) {
	decodedCursor := ""
	if cursor != "" {
		decodedCursorBytes, decodeErr := base64.RawStdEncoding.DecodeString(cursor)
		if decodeErr != nil {
			return gen.Response(http.StatusBadRequest, nil), decodeErr
		}
		decodedCursor = string(decodedCursorBytes)
	}

	sms, nextCursor, err := s.submodelBackend.GetSubmodels(limit, decodedCursor, idShort)
	var converted []map[string]any

	for _, sm := range sms {
		jsonSubmodel, err := jsonization.ToJsonable(sm)
		if err != nil {
			return gen.Response(500, nil), err
		}
		converted = append(converted, jsonSubmodel)
	}

	if err != nil {
		return gen.Response(500, nil), err
	}

	// using the openAPI provided response struct to include paging metadata
	encodedNextCursor := ""
	if nextCursor != "" {
		encodedNextCursor = base64.RawStdEncoding.EncodeToString([]byte(nextCursor))
	}

	res := gen.GetSubmodelsResult{
		PagingMetadata: gen.PagedResultPagingMetadata{
			Cursor: encodedNextCursor,
		},
		Result: converted,
	}
	return gen.Response(200, res), nil
}

// GetSubmodelByID retrieves a specific submodel by its base64-encoded identifier.
// The method decodes the identifier and fetches the submodel from the repository.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - id: Base64-encoded submodel identifier
//   - level: Detail level for response (currently unused)
//   - extent: Response extent specification (currently unused)
//
// Returns:
//   - gen.ImplResponse: Response containing the requested submodel
//   - error: Error if the submodel is not found or decoding fails
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelByID(
	_ /*ctx*/ context.Context,
	id string,
	_ /*level*/ string,
	_ /*extent*/ string,
) (gen.ImplResponse, error) {
	decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(id)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	sm, err := s.submodelBackend.GetSubmodelByID(string(decodedSubmodelIdentifier))
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return gen.Response(404, nil), nil
		}
		if common.IsErrNotFound(err) {
			return gen.Response(404, nil), err
		}
		_, _ = fmt.Printf("[DEBUG] GetSubmodelByID: Error getting submodel '%s': %v\n", string(decodedSubmodelIdentifier), err)
		return gen.Response(500, err.Error()), err
	}
	jsonSubmodel, err := jsonization.ToJsonable(sm)
	if err != nil {
		_, _ = fmt.Printf("[DEBUG] GetSubmodelByID: Error converting submodel '%s' to JSON: %v\n", string(decodedSubmodelIdentifier), err)
		return gen.Response(500, err.Error()), err
	}
	return gen.Response(200, jsonSubmodel), nil
}

// GetSignedSubmodelByID retrieves a signed submodel (JWS compact serialization) by its base64-encoded identifier.
func (s *SubmodelRepositoryAPIAPIService) GetSignedSubmodelByID(
	_ /*ctx*/ context.Context,
	id string,
	_ /*level*/ string,
	_ /*extent*/ string,
) (gen.ImplResponse, error) {
	// Decode the base64-encoded submodel identifier
	// decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(id)
	// if decodeErr != nil {
	// 	return gen.Response(http.StatusBadRequest, nil), decodeErr
	// }

	// // Get the signed submodel (JWS compact serialization) from the database layer
	// jwsString, err := s.submodelBackend.GetSignedSubmodel(string(decodedSubmodelIdentifier), false)
	// if err != nil {
	// 	if errors.Is(err, sql.ErrNoRows) {
	// 		return gen.Response(404, nil), nil
	// 	}
	// 	if common.IsErrNotFound(err) {
	// 		return gen.Response(404, nil), err
	// 	}
	// 	// Check for signing configuration error
	// 	if err.Error() == "JWS signing not configured: private key not loaded" {
	// 		return gen.Response(http.StatusNotFound, nil), nil
	// 	}
	// 	return gen.Response(500, nil), err
	// }

	return gen.Response(http.StatusOK, nil), nil
}

// GetSignedSubmodelByIDValueOnly retrieves a signed submodel in its Value-Only representation by its base64-encoded identifier.
func (s *SubmodelRepositoryAPIAPIService) GetSignedSubmodelByIDValueOnly(
	_ /*ctx*/ context.Context,
	id string,
	_ /*level*/ string,
	_ /*extent*/ string,
) (gen.ImplResponse, error) {
	// Decode the base64-encoded submodel identifier
	// decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(id)
	// if decodeErr != nil {
	// 	return gen.Response(http.StatusBadRequest, nil), decodeErr
	// }

	// // Get the signed submodel (JWS compact serialization) from the database layer
	// jwsString, err := s.submodelBackend.GetSignedSubmodel(string(decodedSubmodelIdentifier), true)
	// if err != nil {
	// 	if errors.Is(err, sql.ErrNoRows) {
	// 		return gen.Response(404, nil), nil
	// 	}
	// 	if common.IsErrNotFound(err) {
	// 		return gen.Response(404, nil), err
	// 	}
	// 	// Check for signing configuration error
	// 	if err.Error() == "JWS signing not configured: private key not loaded" {
	// 		return gen.Response(http.StatusNotFound, nil), nil
	// 	}
	// 	return gen.Response(500, nil), err
	// }

	return gen.Response(http.StatusOK, nil), nil
}

// DeleteSubmodelByID removes a submodel from the repository by its base64-encoded identifier.
// The method decodes the identifier and deletes the corresponding submodel.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - id: Base64-encoded submodel identifier
//
// Returns:
//   - gen.ImplResponse: Response indicating successful deletion
//   - error: Error if the submodel is not found or deletion fails
func (s *SubmodelRepositoryAPIAPIService) DeleteSubmodelByID(
	_ /*ctx*/ context.Context,
	id string,
) (gen.ImplResponse, error) {
	// decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(id)
	// if decodeErr != nil {
	// 	return gen.Response(http.StatusBadRequest, nil), decodeErr
	// }
	// err := s.submodelBackend.DeleteSubmodel(string(decodedSubmodelIdentifier), nil)
	// if err != nil {
	// 	if errors.Is(err, sql.ErrNoRows) {
	// 		return gen.Response(404, nil), nil
	// 	}
	// 	return gen.Response(500, nil), err
	// }
	return gen.Response(204, nil), nil
}

// PostSubmodel creates a new submodel in the repository.
// The method validates and persists the provided submodel data.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodel: The submodel data to create
//
// Returns:
//   - gen.ImplResponse: Response containing the created submodel (HTTP 201)
//   - error: Error if the creation fails
func (s *SubmodelRepositoryAPIAPIService) PostSubmodel(
	_ /*ctx*/ context.Context,
	submodel types.ISubmodel,
) (gen.ImplResponse, error) {
	err := s.submodelBackend.CreateSubmodel(submodel)

	if err != nil {
		if common.IsErrConflict(err) {
			return common.NewErrorResponse(
				err,
				http.StatusConflict,
				"SMRepo",
				"PostSubmodel",
				"IDCONFLICT",
			), nil
		}

		if common.IsErrBadRequest(err) {
			return common.NewErrorResponse(
				err,
				http.StatusBadRequest,
				"SMRepo",
				"PostSubmodel",
				"Invalid submodel data provided",
			), nil
		}

		_, _ = fmt.Println("Error creating submodel: " + err.Error())

		return gen.Response(500, nil), err
	}

	submodelJsonable, err := jsonization.ToJsonable(submodel)
	if err != nil {
		return common.NewErrorResponse(
			err,
			http.StatusBadRequest,
			"SMRepo",
			"PostSubmodel",
			"Invalid submodel data provided",
		), nil
	}

	return gen.Response(201, submodelJsonable), nil
}

// GetAllSubmodelsMetadata retrieves metadata attributes of all submodels.
// This method is currently not implemented and returns a not implemented error.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - semanticID: Semantic identifier for filtering
//   - idShort: Short identifier for filtering
//   - limit: Maximum number of results
//   - cursor: Pagination cursor
//
// Returns:
//   - gen.ImplResponse: Response with submodel metadata (when implemented)
//   - error: Currently returns "not implemented" error
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelsMetadata(
	_ /*ctx*/ context.Context,
	semanticID string,
	idShort string,
	limit int32,
	cursor string) (gen.ImplResponse, error) {
	// sms, nextCursor, err := s.submodelBackend.GetAllSubmodelsMetadata(limit, cursor, idShort, semanticID)
	// if err != nil {
	// 	return gen.Response(500, nil), err
	// }
	// var converted []map[string]any

	// for _, sm := range sms {
	// 	jsonSubmodel, err := jsonization.ToJsonable(&sm)
	// 	if err != nil {
	// 		return gen.Response(500, nil), err
	// 	}
	// 	converted = append(converted, jsonSubmodel)
	// }
	// // using the openAPI provided response struct to include paging metadata
	// res := gen.GetSubmodelsMetadataResult{
	// 	PagingMetadata: gen.PagedResultPagingMetadata{
	// 		Cursor: nextCursor,
	// 	},
	// 	Result: converted,
	// }
	return gen.Response(200, nil), nil

	// TODO - update GetAllSubmodelsMetadata with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, GetSubmodelsMetadataResult{}) or use other options such as http.Ok ...
	// return gen.Response(200, GetSubmodelsMetadataResult{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	// return gen.Response(http.StatusNotImplemented, nil), errors.New("GetAllSubmodelsMetadata method not implemented")
}

// GetAllSubmodelsValueOnly - Returns all Submodels in their ValueOnly representation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelsValueOnly(ctx context.Context, semanticID string, idShort string, limit int32, cursor string, level string, extent string) (gen.ImplResponse, error) {
	_ = ctx
	_ = semanticID
	_ = level
	_ = extent

	decodedCursor := ""
	if cursor != "" {
		decodedCursorBytes, decodeErr := base64.RawStdEncoding.DecodeString(cursor)
		if decodeErr != nil {
			return gen.Response(http.StatusBadRequest, nil), decodeErr
		}
		decodedCursor = string(decodedCursorBytes)
	}

	sms, nextCursor, err := s.submodelBackend.GetSubmodels(limit, decodedCursor, idShort)
	if err != nil {
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	valueOnlyResults := make([]map[string]any, 0, len(sms))
	for _, sm := range sms {
		valueOnly, convErr := gen.SubmodelToValueOnly(sm)
		if convErr != nil {
			return gen.Response(http.StatusInternalServerError, nil), convErr
		}
		valueOnlyResults = append(valueOnlyResults, submodelValueToAnyMap(valueOnly))
	}

	encodedNextCursor := ""
	if nextCursor != "" {
		encodedNextCursor = base64.RawStdEncoding.EncodeToString([]byte(nextCursor))
	}

	res := gen.GetSubmodelsValueResult{
		PagingMetadata: gen.PagedResultPagingMetadata{
			Cursor: encodedNextCursor,
		},
		Result: valueOnlyResults,
	}

	return gen.Response(http.StatusOK, res), nil
}

// GetAllSubmodelsReference - Returns the References for all Submodels
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelsReference(ctx context.Context, semanticID string, idShort string, limit int32, cursor string, level string) (gen.ImplResponse, error) {
	// TODO - update GetAllSubmodelsReference with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, GetReferencesResult{}) or use other options such as http.Ok ...
	// return gen.Response(200, GetReferencesResult{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("GetAllSubmodelsReference method not implemented")
}

// GetAllSubmodelsPath - Returns all Submodels in the Path notation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelsPath(ctx context.Context, semanticID string, idShort string, limit int32, cursor string, level string) (gen.ImplResponse, error) {
	// TODO - update GetAllSubmodelsPath with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, GetPathItemsResult{}) or use other options such as http.Ok ...
	// return gen.Response(200, GetPathItemsResult{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("GetAllSubmodelsPath method not implemented")
}

// PutSubmodelByID - Updates an existing Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PutSubmodelByID(ctx context.Context, submodelIdentifier string, submodel types.ISubmodel) (gen.ImplResponse, error) {
	// decodedIdentifier, err := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	// if err != nil {
	// 	return common.NewErrorResponse(err, http.StatusBadRequest, "SMRepo", "PatchSubmodelByID", "Malformed Submodel Identifier"), nil
	// }

	// if string(decodedIdentifier) != submodel.ID() {
	// 	return common.NewErrorResponse(errors.New("submodel ID in path and body do not match"), http.StatusBadRequest, "SMRepo", "PatchSubmodelByID", "ID Mismatch"), nil
	// }

	// isUpdate, err := s.submodelBackend.PutSubmodel(string(decodedIdentifier), submodel)
	// if err != nil {
	// 	if common.IsErrBadRequest(err) {
	// 		return common.NewErrorResponse(
	// 			err,
	// 			http.StatusBadRequest,
	// 			"SMRepo",
	// 			"PatchSubmodelByID",
	// 			"BadRequest",
	// 		), err
	// 	}
	// 	if common.IsErrConflict(err) {
	// 		return common.NewErrorResponse(
	// 			err,
	// 			http.StatusConflict,
	// 			"SMRepo",
	// 			"PutSubmodelByID",
	// 			"Conflict",
	// 		), err
	// 	}
	// 	return common.NewErrorResponse(
	// 		err,
	// 		http.StatusInternalServerError,
	// 		"SMRepo",
	// 		"PatchSubmodelByID",
	// 		"InternalServerError",
	// 	), err
	// }
	// if isUpdate {
	// 	return gen.Response(http.StatusNoContent, nil), nil
	// } else {
	// 	return gen.Response(http.StatusCreated, submodel), nil
	// }
	return gen.Response(http.StatusNotImplemented, nil), errors.New("PutSubmodelByID method not implemented")
}

// PatchSubmodelByID - Updates an existing Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelByID(ctx context.Context, submodelIdentifier string, submodel types.ISubmodel, level string) (gen.ImplResponse, error) {
	// TODO - update PatchSubmodelByID with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return gen.Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("PatchSubmodelByID method not implemented")
}

// GetSubmodelByIDMetadata - Returns the metadata attributes of a specific Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelByIDMetadata(ctx context.Context, submodelIdentifier string) (gen.ImplResponse, error) {
	// TODO - update GetSubmodelByIDMetadata with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, SubmodelMetadata{}) or use other options such as http.Ok ...
	// return gen.Response(200, SubmodelMetadata{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("GetSubmodelByIDMetadata method not implemented")
}

// PatchSubmodelByIDMetadata - Updates the metadata attributes of an existing Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelByIDMetadata(ctx context.Context, submodelIdentifier string, submodelMetadata gen.SubmodelMetadata) (gen.ImplResponse, error) {
	// TODO - update PatchSubmodelByIDMetadata with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return gen.Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("PatchSubmodelByIDMetadata method not implemented")
}

// GetSubmodelByIDValueOnly - Returns a specific Submodel in the ValueOnly representation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelByIDValueOnly(ctx context.Context, submodelIdentifier string, level string, extent string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	_ = extent

	decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	sm, err := s.submodelBackend.GetSubmodelByID(string(decodedSubmodelIdentifier))
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return gen.Response(http.StatusNotFound, nil), nil
		}
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	valueOnly, convErr := gen.SubmodelToValueOnly(sm)
	if convErr != nil {
		return gen.Response(http.StatusInternalServerError, nil), convErr
	}

	return gen.Response(http.StatusOK, valueOnly), nil
}

// PatchSubmodelByIDValueOnly - Updates the values of an existing Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelByIDValueOnly(ctx context.Context, submodelIdentifier string, body gen.SubmodelValue, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level

	decodedIdentifier, err := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if err != nil {
		return common.NewErrorResponse(err, http.StatusBadRequest, "SMRepo", "PatchSubmodelByIDValueOnly", "Malformed Submodel Identifier"), nil
	}

	err = s.submodelBackend.UpdateSubmodelValueOnly(string(decodedIdentifier), body)
	if err != nil {
		if common.IsErrBadRequest(err) {
			return common.NewErrorResponse(err, http.StatusBadRequest, "SMRepo", "PatchSubmodelByIDValueOnly", "Bad Request while Updating Submodel Value"), nil
		}
		if common.IsErrNotFound(err) {
			return common.NewErrorResponse(err, http.StatusNotFound, "SMRepo", "PatchSubmodelByIDValueOnly", fmt.Sprintf("Submodel with id %s or SubmodelElement in request body was not found", decodedIdentifier)), nil
		}
		_, _ = fmt.Println(err)
		return common.NewErrorResponse(err, http.StatusInternalServerError, "SMRepo", "PatchSubmodelByIDValueOnly", "Unknown Error - check console for details"), nil
	}
	return gen.Response(http.StatusNoContent, nil), nil
}

// GetSubmodelByIDReference - Returns the Reference of a specific Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelByIDReference(ctx context.Context, submodelIdentifier string) (gen.ImplResponse, error) {
	// TODO - update GetSubmodelByIDReference with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, Reference{}) or use other options such as http.Ok ...
	// return gen.Response(200, Reference{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("GetSubmodelByIDReference method not implemented")
}

// GetSubmodelByIDPath - Returns a specific Submodel in the Path notation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelByIDPath(ctx context.Context, submodelIdentifier string, level string) (gen.ImplResponse, error) {
	// TODO - update GetSubmodelByIDPath with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, []string{}) or use other options such as http.Ok ...
	// return gen.Response(200, []string{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("GetSubmodelByIDPath method not implemented")
}

// GetAllSubmodelElements retrieves all submodel elements from a specific submodel including their hierarchy.
// The method supports pagination and different detail levels for the response.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodelIdentifier: Base64-encoded identifier of the parent submodel
//   - limit: Maximum number of elements to return
//   - cursor: Pagination cursor
//   - level: Detail level for response
//   - extent: Response extent specification
//
// Returns:
//   - gen.ImplResponse: Response containing submodel elements
//   - error: Error if the operation fails
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelElements(_ /*ctx*/ context.Context, submodelIdentifier string, limit int32, cursor string, _ /*level*/ string, _ /*extent*/ string) (gen.ImplResponse, error) {
	decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	decodedCursor := ""
	if cursor != "" {
		decodedCursorBytes, err := base64.RawStdEncoding.DecodeString(cursor)
		if err != nil {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		decodedCursor = string(decodedCursorBytes)
	}

	var limitPtr *int
	if limit > 0 {
		parsedLimit := int(limit)
		limitPtr = &parsedLimit
	}

	elements, nextCursor, err := s.submodelBackend.GetSubmodelElements(string(decodedSubmodelIdentifier), limitPtr, decodedCursor, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return gen.Response(http.StatusNotFound, nil), nil
		}
		if common.IsErrBadRequest(err) {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	converted := make([]map[string]any, 0, len(elements))
	for _, element := range elements {
		jsonSubmodelElement, convErr := jsonization.ToJsonable(element)
		if convErr != nil {
			return gen.Response(http.StatusInternalServerError, nil), convErr
		}
		converted = append(converted, jsonSubmodelElement)
	}

	encodedNextCursor := ""
	if nextCursor != "" {
		encodedNextCursor = base64.RawStdEncoding.EncodeToString([]byte(nextCursor))
	}

	res := gen.GetSubmodelElementsResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodedNextCursor},
		Result:         converted,
	}

	return gen.Response(http.StatusOK, res), nil
}

// PostSubmodelElementSubmodelRepo creates a new submodel element within a specified submodel.
// The method validates and persists the provided submodel element data.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodelIdentifier: Base64-encoded identifier of the parent submodel
//   - submodelElement: The submodel element data to create
//
// Returns:
//   - gen.ImplResponse: Response containing the created submodel element (HTTP 201)
//   - error: Error if the creation fails
func (s *SubmodelRepositoryAPIAPIService) PostSubmodelElementSubmodelRepo(_ /*ctx*/ context.Context, submodelIdentifier string, submodelElement types.ISubmodelElement) (gen.ImplResponse, error) {
	// // TODO: Authorization logic to be implemented
	// // return gen.Response(401, Result{}), nil
	// // return gen.Response(403, Result{}), nil

	// decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	// if decodeErr != nil {
	// 	return gen.Response(http.StatusBadRequest, nil), decodeErr
	// }

	// if err := s.submodelBackend.AddSubmodelElement(string(decodedSubmodelIdentifier), submodelElement); err != nil {
	// 	if common.IsErrNotFound(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusNotFound, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "404", "SMREPO-PostSubmodelElementSubmodelRepo-404-NotFound", string(timestamp))}), nil
	// 	}
	// 	if common.IsErrConflict(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusConflict, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "409", "SMREPO-PostSubmodelElementSubmodelRepo-409-Conflict", string(timestamp))}), nil
	// 	}
	// 	if common.IsErrBadRequest(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusBadRequest, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "400", "SMREPO-PostSubmodelElementSubmodelRepo-400-BadRequest", string(timestamp))}), nil
	// 	}
	// 	if common.IsInternalServerError(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusInternalServerError, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "500", "SMREPO-PostSubmodelElementSubmodelRepo-500-InternalServerError", string(timestamp))}), nil
	// 	}
	// 	return gen.Response(http.StatusInternalServerError, nil), err
	// }

	return gen.Response(http.StatusCreated, submodelElement), nil
}

// GetAllSubmodelElementsMetadataSubmodelRepo - Returns the metadata attributes of all submodel elements including their hierarchy
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelElementsMetadataSubmodelRepo(ctx context.Context, submodelIdentifier string, limit int32, cursor string) (gen.ImplResponse, error) {
	_ = ctx

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	decodedCursor, cursorDecodeErr := decodeBase64RawStd(cursor)
	if cursorDecodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), cursorDecodeErr
	}

	elements, nextCursor, err := s.submodelBackend.GetSubmodelElements(decodedSubmodelIdentifier, buildLimitPtr(limit), decodedCursor, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return gen.Response(http.StatusNotFound, nil), nil
		}
		if common.IsErrBadRequest(err) {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	metadataResult := make([]gen.SubmodelElementMetadata, 0, len(elements))
	for _, element := range elements {
		metadata, conversionErr := toSubmodelElementMetadata(element)
		if conversionErr != nil {
			return gen.Response(http.StatusInternalServerError, nil), conversionErr
		}
		metadataResult = append(metadataResult, metadata)
	}

	res := gen.GetSubmodelElementsMetadataResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodeBase64RawStd(nextCursor)},
		Result:         metadataResult,
	}

	return gen.Response(http.StatusOK, res), nil
}

// GetAllSubmodelElementsValueOnlySubmodelRepo - Returns all submodel elements including their hierarchy in the ValueOnly representation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelElementsValueOnlySubmodelRepo(ctx context.Context, submodelIdentifier string, limit int32, cursor string, level string, extent string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	_ = extent

	decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	decodedCursor := ""
	if cursor != "" {
		decodedCursorBytes, err := base64.RawStdEncoding.DecodeString(cursor)
		if err != nil {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		decodedCursor = string(decodedCursorBytes)
	}

	var limitPtr *int
	if limit > 0 {
		parsedLimit := int(limit)
		limitPtr = &parsedLimit
	}

	elements, nextCursor, err := s.submodelBackend.GetSubmodelElements(string(decodedSubmodelIdentifier), limitPtr, decodedCursor, true)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return gen.Response(http.StatusNotFound, nil), nil
		}
		if common.IsErrBadRequest(err) {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	valueOnlyResults := make([]gen.SubmodelElementValue, 0, len(elements))
	for _, element := range elements {
		valueOnly, convErr := gen.SubmodelElementToValueOnly(element)
		if convErr != nil {
			return gen.Response(http.StatusInternalServerError, nil), convErr
		}
		if valueOnly == nil {
			continue
		}

		idShort := element.IDShort()
		if idShort == nil || *idShort == "" {
			continue
		}

		wrapped := make(gen.SubmodelElementCollectionValue)
		wrapped[*idShort] = valueOnly
		valueOnlyResults = append(valueOnlyResults, wrapped)
	}

	encodedNextCursor := ""
	if nextCursor != "" {
		encodedNextCursor = base64.RawStdEncoding.EncodeToString([]byte(nextCursor))
	}

	res := gen.GetSubmodelElementsValueResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodedNextCursor},
		Result:         valueOnlyResults,
	}

	return gen.Response(http.StatusOK, res), nil
}

// GetAllSubmodelElementsReferenceSubmodelRepo - Returns the References of all submodel elements
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelElementsReferenceSubmodelRepo(ctx context.Context, submodelIdentifier string, limit int32, cursor string, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	decodedCursor, cursorDecodeErr := decodeBase64RawStd(cursor)
	if cursorDecodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), cursorDecodeErr
	}

	elements, nextCursor, err := s.submodelBackend.GetSubmodelElements(decodedSubmodelIdentifier, buildLimitPtr(limit), decodedCursor, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return gen.Response(http.StatusNotFound, nil), nil
		}
		if common.IsErrBadRequest(err) {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	references := make([]types.IReference, 0, len(elements))
	for _, element := range elements {
		idShort := element.IDShort()
		if idShort == nil || *idShort == "" {
			continue
		}

		modelTypeLiteral := getModelTypeLiteral(element)
		if modelTypeLiteral == "" {
			return gen.Response(http.StatusInternalServerError, nil), common.NewInternalServerError("SMREPO-GETALLSMEREF-MODELTYPE Empty modelType for submodel element")
		}

		reference, referenceErr := buildModelReference(decodedSubmodelIdentifier, modelTypeLiteral, *idShort)
		if referenceErr != nil {
			return gen.Response(http.StatusInternalServerError, nil), referenceErr
		}

		references = append(references, reference)
	}

	res := gen.GetReferencesResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodeBase64RawStd(nextCursor)},
		Result:         references,
	}

	return gen.Response(http.StatusOK, res), nil
}

// GetAllSubmodelElementsPathSubmodelRepo - Returns all submodel elements including their hierarchy in the Path notation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelElementsPathSubmodelRepo(ctx context.Context, submodelIdentifier string, limit int32, cursor string, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	decodedCursor, cursorDecodeErr := decodeBase64RawStd(cursor)
	if cursorDecodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), cursorDecodeErr
	}

	elements, nextCursor, err := s.submodelBackend.GetSubmodelElements(decodedSubmodelIdentifier, buildLimitPtr(limit), decodedCursor, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return gen.Response(http.StatusNotFound, nil), nil
		}
		if common.IsErrBadRequest(err) {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	paths := make([]string, 0, len(elements))
	for _, element := range elements {
		idShort := element.IDShort()
		if idShort == nil || *idShort == "" {
			continue
		}
		paths = append(paths, *idShort)
	}

	res := gen.GetPathItemsResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodeBase64RawStd(nextCursor)},
		Result:         paths,
	}

	return gen.Response(http.StatusOK, res), nil
}

// GetSubmodelElementByPathSubmodelRepo - Returns a specific submodel element from the Submodel at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelElementByPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, level string, extent string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	_ = extent

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	element, err := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, idShortPath, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return common.NewErrorResponse(
				err,
				http.StatusNotFound,
				"SMREPO",
				"GetSubmodelElementByPathSubmodelRepo",
				"NotFoundGSME",
			), err
		}
		if common.IsErrBadRequest(err) {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	converted, convErr := jsonization.ToJsonable(element)
	if convErr != nil {
		return gen.Response(http.StatusInternalServerError, nil), convErr
	}

	return gen.Response(http.StatusOK, converted), nil
}

// PutSubmodelElementByPathSubmodelRepo updates an existing submodel element at a specified path within submodel elements hierarchy.
// The method replaces the existing element with the provided data.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodelIdentifier: Base64-encoded identifier of the parent submodel
//   - idShortPath: Path to the target submodel element
//   - submodelElement: Updated submodel element data
//   - level: Detail level for response
//
// Returns:
//   - gen.ImplResponse: Response indicating successful update (HTTP 204)
//   - error: Error if the update fails
func (s *SubmodelRepositoryAPIAPIService) PutSubmodelElementByPathSubmodelRepo(_ /*ctx*/ context.Context, submodelIdentifier string, idShortPath string, submodelElement types.ISubmodelElement, _ /*level*/ string) (gen.ImplResponse, error) {
	// Decode the submodel identifier from base64
	// decodedSubmodelID, err := base64.RawURLEncoding.DecodeString(submodelIdentifier)
	// if err != nil {
	// 	return gen.Response(http.StatusBadRequest, gen.Result{Messages: []gen.Message{{Text: "Invalid submodel identifier"}}}), nil
	// }

	// // Update the submodel element using the backend with isPut set to true
	// err = s.submodelBackend.UpdateSubmodelElement(string(decodedSubmodelID), idShortPath, submodelElement, true)
	// if err != nil {
	// 	if common.IsErrNotFound(err) {
	// 		return gen.Response(http.StatusNotFound, gen.Result{Messages: []gen.Message{{Text: err.Error()}}}), nil
	// 	}
	// 	if common.IsErrConflict(err) {
	// 		return gen.Response(http.StatusConflict, gen.Result{Messages: []gen.Message{{Text: err.Error()}}}), nil
	// 	}
	// 	return gen.Response(http.StatusInternalServerError, gen.Result{Messages: []gen.Message{{Text: err.Error()}}}), nil
	// }

	return gen.Response(http.StatusNoContent, nil), nil
}

// PostSubmodelElementByPathSubmodelRepo creates a new submodel element at a specified path within submodel elements hierarchy.
// The method creates a nested element under the specified path.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodelIdentifier: Base64-encoded identifier of the parent submodel
//   - idShortPath: Path where the new element should be created
//   - submodelElement: The submodel element data to create
//
// Returns:
//   - gen.ImplResponse: Response containing the created submodel element (HTTP 201)
//   - error: Error if the creation fails
func (s *SubmodelRepositoryAPIAPIService) PostSubmodelElementByPathSubmodelRepo(_ /*ctx*/ context.Context, submodelIdentifier string, idShortPath string, submodelElement types.ISubmodelElement) (gen.ImplResponse, error) {
	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil
	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	// if decodeErr != nil {
	// 	return gen.Response(http.StatusBadRequest, nil), decodeErr
	// }

	// if err := s.submodelBackend.AddSubmodelElementWithPath(string(decodedSubmodelIdentifier), idShortPath, submodelElement); err != nil {
	// 	if common.IsErrNotFound(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusNotFound, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "404", "SMREPO-PostSubmodelElementByPathSubmodelRepo-404-NotFound", string(timestamp))}), nil
	// 	}
	// 	if common.IsErrConflict(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusConflict, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "409", "SMREPO-PostSubmodelElementByPathSubmodelRepo-409-Conflict", string(timestamp))}), nil
	// 	}
	// 	if common.IsErrBadRequest(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusBadRequest, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "400", "SMREPO-PostSubmodelElementByPathSubmodelRepo-400-BadRequest", string(timestamp))}), nil
	// 	}
	// 	if common.IsInternalServerError(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusInternalServerError, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "500", "SMREPO-PostSubmodelElementByPathSubmodelRepo-500-InternalServerError", string(timestamp))}), nil
	// 	}
	// 	return gen.Response(http.StatusInternalServerError, nil), err
	// }

	return gen.Response(http.StatusCreated, submodelElement), nil
}

// DeleteSubmodelElementByPathSubmodelRepo deletes a submodel element at a specified path within the submodel elements hierarchy.
// The method removes the element and all its children from the specified path.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodelIdentifier: Base64-encoded identifier of the parent submodel
//   - idShortPath: Path to the submodel element to delete
//
// Returns:
//   - gen.ImplResponse: Response indicating successful deletion (HTTP 204)
//   - error: Error if the deletion fails
func (s *SubmodelRepositoryAPIAPIService) DeleteSubmodelElementByPathSubmodelRepo(_ /*ctx*/ context.Context, submodelIdentifier string, idShortPath string) (gen.ImplResponse, error) {
	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	// if decodeErr != nil {
	// 	return gen.Response(http.StatusBadRequest, nil), decodeErr
	// }

	// if err := s.submodelBackend.DeleteSubmodelElementByPath(string(decodedSubmodelIdentifier), idShortPath); err != nil {
	// 	if common.IsErrNotFound(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusNotFound, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "404", "SMREPO-DeleteSubmodelElementByPathSubmodelRepo-404-NotFound", string(timestamp))}), nil
	// 	}
	// 	if common.IsErrBadRequest(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusBadRequest, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "400", "SMREPO-DeleteSubmodelElementByPathSubmodelRepo-400-BadRequest", string(timestamp))}), nil
	// 	}
	// 	if common.IsInternalServerError(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusInternalServerError, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "500", "SMREPO-DeleteSubmodelElementByPathSubmodelRepo-500-InternalServerError", string(timestamp))}), nil
	// 	}
	// 	if common.IsErrBadRequest(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusBadRequest, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "400", "SMREPO-DeleteSubmodelElementByPathSubmodelRepo-400-BadRequest", string(timestamp))}), nil
	// 	}
	// 	return gen.Response(http.StatusInternalServerError, nil), err
	// }

	return gen.Response(http.StatusNoContent, nil), nil
}

// PatchSubmodelElementByPathSubmodelRepo - Updates an existing SubmodelElement
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelElementByPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, submodelElement types.ISubmodelElement, level string) (gen.ImplResponse, error) {
	// TODO - update PatchSubmodelElementByPathSubmodelRepo with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return gen.Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("PatchSubmodelElementByPathSubmodelRepo method not implemented")
}

// GetSubmodelElementByPathMetadataSubmodelRepo - Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelElementByPathMetadataSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string) (gen.ImplResponse, error) {
	_ = ctx

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	element, err := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, idShortPath, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return gen.Response(http.StatusNotFound, nil), nil
		}
		if common.IsErrBadRequest(err) {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	metadata, conversionErr := toSubmodelElementMetadata(element)
	if conversionErr != nil {
		return gen.Response(http.StatusInternalServerError, nil), conversionErr
	}

	return gen.Response(http.StatusOK, metadata), nil
}

// PatchSubmodelElementByPathMetadataSubmodelRepo - Updates the metadata attributes an existing SubmodelElement
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelElementByPathMetadataSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, submodelElementMetadata gen.SubmodelElementMetadata) (gen.ImplResponse, error) {
	// TODO - update PatchSubmodelElementByPathMetadataSubmodelRepo with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return gen.Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("PatchSubmodelElementByPathMetadataSubmodelRepo method not implemented")
}

// GetSubmodelElementByPathValueOnlySubmodelRepo - Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelElementByPathValueOnlySubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, level string, extent string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	_ = extent

	decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	element, err := s.submodelBackend.GetSubmodelElement(string(decodedSubmodelIdentifier), idShortPath, true)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return gen.Response(http.StatusNotFound, nil), nil
		}
		if common.IsErrBadRequest(err) {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	valueOnly, convErr := gen.SubmodelElementToValueOnly(element)
	if convErr != nil {
		return gen.Response(http.StatusInternalServerError, nil), convErr
	}

	if valueOnly == nil {
		return gen.Response(http.StatusNotFound, nil), errors.New("element cannot be serialized in value-only format")
	}

	return gen.Response(http.StatusOK, valueOnly), nil
}

// PatchSubmodelElementByPathValueOnlySubmodelRepo - Updates the value of an existing SubmodelElement
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelElementByPathValueOnlySubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, submodelElementValue gen.SubmodelElementValue, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level

	decodedIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	err := s.submodelBackend.UpdateSubmodelElementValueOnly(string(decodedIdentifier), idShortPath, submodelElementValue)
	if err != nil {
		if common.IsErrBadRequest(err) {
			return gen.Response(http.StatusBadRequest, gen.Result{Messages: []gen.Message{{Text: err.Error()}}}), nil
		}
		if common.IsErrNotFound(err) {
			return gen.Response(http.StatusNotFound, gen.Result{Messages: []gen.Message{{Text: err.Error()}}}), nil
		}
		return gen.Response(http.StatusInternalServerError, gen.Result{Messages: []gen.Message{{Text: err.Error()}}}), nil
	}

	return gen.Response(http.StatusNoContent, nil), nil
}

// GetSubmodelElementByPathReferenceSubmodelRepo - Returns the Referee of a specific submodel element from the Submodel at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelElementByPathReferenceSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string) (gen.ImplResponse, error) {
	_ = ctx

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	element, err := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, idShortPath, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return gen.Response(http.StatusNotFound, nil), nil
		}
		if common.IsErrBadRequest(err) {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	modelTypeLiteral := getModelTypeLiteral(element)
	if modelTypeLiteral == "" {
		return gen.Response(http.StatusInternalServerError, nil), common.NewInternalServerError("SMREPO-GETSMEREF-MODELTYPE Empty modelType for submodel element")
	}

	reference, referenceErr := buildModelReference(decodedSubmodelIdentifier, modelTypeLiteral, idShortPath)
	if referenceErr != nil {
		return gen.Response(http.StatusInternalServerError, nil), referenceErr
	}

	return gen.Response(http.StatusOK, reference), nil
}

// GetSubmodelElementByPathPathSubmodelRepo - Returns a specific submodel element from the Submodel at a specified path in the Path notation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelElementByPathPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return gen.Response(http.StatusBadRequest, nil), decodeErr
	}

	_, err := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, idShortPath, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return gen.Response(http.StatusNotFound, nil), nil
		}
		if common.IsErrBadRequest(err) {
			return gen.Response(http.StatusBadRequest, nil), err
		}
		return gen.Response(http.StatusInternalServerError, nil), err
	}

	return gen.Response(http.StatusOK, []string{idShortPath}), nil
}

// GetFileByPathSubmodelRepo - Downloads file content from a specific submodel element from the Submodel at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetFileByPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string) (gen.ImplResponse, error) {
	// // Decode Submodel Identifier
	// decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	// if decodeErr != nil {
	// 	return gen.Response(http.StatusBadRequest, nil), decodeErr
	// }
	// submodelIdentifier = string(decodedSubmodelIdentifier)

	// // See if Submodel Exists
	// exists, err := s.submodelBackend.DoesSubmodelExist(submodelIdentifier, nil)
	// if err != nil || !exists {
	// 	timestamp := common.GetCurrentTimestamp()
	// 	return gen.Response(http.StatusNotFound, []common.ErrorHandler{*common.NewErrorHandler("Error", errors.New("submodel not found"), "404", "SMREPO-GetFileByPathSubmodelRepo-404-NotFound", string(timestamp))}), nil
	// }

	// if common.IsErrNotFound(err) {
	// 	timestamp := common.GetCurrentTimestamp()
	// 	return gen.Response(http.StatusNotFound, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "404", "SMREPO-GetFileByPathSubmodelRepo-404-NotFound", string(timestamp))}), nil
	// }

	// // Get Submodel Element
	// fileSme, err := s.submodelBackend.GetSubmodelElement(submodelIdentifier, idShortPath, false)
	// if common.IsErrNotFound(err) {
	// 	timestamp := common.GetCurrentTimestamp()
	// 	return gen.Response(http.StatusNotFound, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "404", "SMREPO-GetFileByPathSubmodelRepo-404-NotFound", string(timestamp))}), nil
	// } else if err != nil {
	// 	return gen.Response(http.StatusInternalServerError, nil), err
	// }

	// // check if file value starts with http:// or https://
	// fileValue, ok := fileSme.(*types.File)
	// if !ok {
	// 	timestamp := common.GetCurrentTimestamp()
	// 	return gen.Response(http.StatusBadRequest, []common.ErrorHandler{*common.NewErrorHandler("Error", errors.New("submodel element is not of type File"), "400", "SMREPO-GetFileByPathSubmodelRepo-400-BadRequest", string(timestamp))}), nil
	// }

	// fileURL := fileValue.Value()
	// // Check if value is empty
	// if fileURL == nil || *fileURL == "" {
	// 	timestamp := common.GetCurrentTimestamp()
	// 	return gen.Response(http.StatusNotFound, []common.ErrorHandler{*common.NewErrorHandler("Error", errors.New("file value is empty"), "404", "SMREPO-GetFileByPathSubmodelRepo-404-NotFound", string(timestamp))}), nil
	// }

	// if strings.HasPrefix(*fileURL, "http://") || strings.HasPrefix(*fileURL, "https://") {
	// 	// Redirect to the file URL
	// 	return gen.Response(http.StatusFound, openapi.Redirect{Location: *fileURL}), nil
	// }

	// // Check if the value is an OID (stored files in Large Objects)
	// // Retrieve file from Large Object system
	// fileContent, contentType, fileName, err := s.submodelBackend.DownloadFileAttachment(submodelIdentifier, idShortPath)
	// if err != nil {
	// 	if common.IsErrNotFound(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusNotFound, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "404", "SMREPO-GetFileByPathSubmodelRepo-404-NotFound", string(timestamp))}), nil
	// 	}
	// 	return gen.Response(http.StatusInternalServerError, nil), err
	// }

	// // Return file with appropriate content type
	return gen.Response(http.StatusOK, openapi.FileDownload{
		Content:     nil,
		ContentType: "",
		Filename:    "",
	}), nil
}

// PutFileByPathSubmodelRepo - Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PutFileByPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, fileName string, file *os.File) (gen.ImplResponse, error) {
	// // Decode Submodel Identifier
	// decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	// if decodeErr != nil {
	// 	return gen.Response(http.StatusBadRequest, nil), decodeErr
	// }
	// submodelIdentifier = string(decodedSubmodelIdentifier)

	// // Check if Submodel Exists
	// exists, err := s.submodelBackend.DoesSubmodelExist(submodelIdentifier, nil)
	// if err != nil || !exists {
	// 	timestamp := common.GetCurrentTimestamp()
	// 	return gen.Response(http.StatusNotFound, []common.ErrorHandler{*common.NewErrorHandler("Error", errors.New("submodel not found"), "404", "SMREPO-PutFileByPathSubmodelRepo-404-NotFound", string(timestamp))}), nil
	// }

	// // Get Submodel Element to verify it exists and is of type File
	// fileSme, err := s.submodelBackend.GetSubmodelElement(submodelIdentifier, idShortPath, false)
	// if common.IsErrNotFound(err) {
	// 	timestamp := common.GetCurrentTimestamp()
	// 	return gen.Response(http.StatusNotFound, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "404", "SMREPO-PutFileByPathSubmodelRepo-404-NotFound", string(timestamp))}), nil
	// }
	// if err != nil {
	// 	return gen.Response(http.StatusInternalServerError, nil), err
	// }

	// // Verify submodel element is of type File
	// _, ok := fileSme.(*types.File)
	// if !ok {
	// 	timestamp := common.GetCurrentTimestamp()
	// 	return gen.Response(http.StatusBadRequest, []common.ErrorHandler{*common.NewErrorHandler("Error", errors.New("submodel element is not of type File"), "400", "SMREPO-PutFileByPathSubmodelRepo-400-BadRequest", string(timestamp))}), nil
	// }

	// // Upload file attachment using the dedicated handler
	// err = s.submodelBackend.UploadFileAttachment(submodelIdentifier, idShortPath, file, fileName)
	// if err != nil {
	// 	if common.IsErrNotFound(err) {
	// 		timestamp := common.GetCurrentTimestamp()
	// 		return gen.Response(http.StatusNotFound, []common.ErrorHandler{*common.NewErrorHandler("Error", err, "404", "SMREPO-PutFileByPathSubmodelRepo-404-NotFound", string(timestamp))}), nil
	// 	}
	// 	return gen.Response(http.StatusInternalServerError, nil), err
	// }

	return gen.Response(http.StatusNoContent, nil), nil
}

// DeleteFileByPathSubmodelRepo - Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) DeleteFileByPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string) (gen.ImplResponse, error) {
	// // Decode the submodel identifier from base64
	// decodedSubmodelID, err := base64.RawURLEncoding.DecodeString(submodelIdentifier)
	// if err != nil {
	// 	return gen.Response(http.StatusBadRequest, gen.Result{Messages: []gen.Message{{Text: "Invalid submodel identifier"}}}), nil
	// }

	// // Delete the file attachment
	// err = s.submodelBackend.DeleteFileAttachment(string(decodedSubmodelID), idShortPath)
	// if err != nil {
	// 	if common.IsErrNotFound(err) {
	// 		return gen.Response(http.StatusNotFound, gen.Result{Messages: []gen.Message{{Text: err.Error()}}}), nil
	// 	}
	// 	return gen.Response(http.StatusInternalServerError, gen.Result{Messages: []gen.Message{{Text: err.Error()}}}), nil
	// }

	return gen.Response(http.StatusOK, nil), nil
}

// InvokeOperationSubmodelRepo - Synchronously or asynchronously invokes an Operation at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) InvokeOperationSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, operationRequest gen.OperationRequest, async bool) (gen.ImplResponse, error) {
	// TODO - update InvokeOperationSubmodelRepo with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, OperationResult{}) or use other options such as http.Ok ...
	// return gen.Response(200, OperationResult{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(405, Result{}) or use other options such as http.Ok ...
	// return gen.Response(405, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("InvokeOperationSubmodelRepo method not implemented")
}

// InvokeOperationValueOnly - Synchronously or asynchronously invokes an Operation at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) InvokeOperationValueOnly(ctx context.Context, aasIdentifier string, submodelIdentifier string, idShortPath string, operationRequestValueOnly gen.OperationRequestValueOnly, async bool) (gen.ImplResponse, error) {
	// TODO - update InvokeOperationValueOnly with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, OperationResultValueOnly{}) or use other options such as http.Ok ...
	// return gen.Response(200, OperationResultValueOnly{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("InvokeOperationValueOnly method not implemented")
}

// InvokeOperationAsync - Asynchronously invokes an Operation at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) InvokeOperationAsync(ctx context.Context, submodelIdentifier string, idShortPath string, operationRequest gen.OperationRequest) (gen.ImplResponse, error) {
	// TODO - update InvokeOperationAsync with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(202, {}) or use other options such as http.Ok ...
	// return gen.Response(202, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(405, Result{}) or use other options such as http.Ok ...
	// return gen.Response(405, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("InvokeOperationAsync method not implemented")
}

// InvokeOperationAsyncValueOnly - Asynchronously invokes an Operation at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) InvokeOperationAsyncValueOnly(ctx context.Context, aasIdentifier string, submodelIdentifier string, idShortPath string, operationRequestValueOnly gen.OperationRequestValueOnly) (gen.ImplResponse, error) {
	// TODO - update InvokeOperationAsyncValueOnly with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(202, {}) or use other options such as http.Ok ...
	// return gen.Response(202, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("InvokeOperationAsyncValueOnly method not implemented")
}

// GetOperationAsyncStatus - Returns the status of an asynchronously invoked Operation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetOperationAsyncStatus(ctx context.Context, submodelIdentifier string, idShortPath string, handleID string) (gen.ImplResponse, error) {
	// TODO - update GetOperationAsyncStatus with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, BaseOperationResult{}) or use other options such as http.Ok ...
	// return gen.Response(200, BaseOperationResult{}), nil

	// TODO: Uncomment the next line to return response Response(302, {}) or use other options such as http.Ok ...
	// return gen.Response(302, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("GetOperationAsyncStatus method not implemented")
}

// GetOperationAsyncResult - Returns the Operation result of an asynchronously invoked Operation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetOperationAsyncResult(ctx context.Context, submodelIdentifier string, idShortPath string, handleID string) (gen.ImplResponse, error) {
	// TODO - update GetOperationAsyncResult with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, OperationResult{}) or use other options such as http.Ok ...
	// return gen.Response(200, OperationResult{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("GetOperationAsyncResult method not implemented")
}

// GetOperationAsyncResultValueOnly - Returns the Operation result of an asynchronously invoked Operation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetOperationAsyncResultValueOnly(ctx context.Context, submodelIdentifier string, idShortPath string, handleID string) (gen.ImplResponse, error) {
	// TODO - update GetOperationAsyncResultValueOnly with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, OperationResultValueOnly{}) or use other options such as http.Ok ...
	// return gen.Response(200, OperationResultValueOnly{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	return gen.Response(http.StatusNotImplemented, nil), errors.New("GetOperationAsyncResultValueOnly method not implemented")
}

const smRepoComponentName = "SubmodelRepository"

// QuerySubmodels returns all Submodels that match the input query.
// It supports filtering based on the query language and provides pagination through cursor-based navigation.
//
// Parameters:
//   - ctx: Request context for security and cancellation
//   - limit: Maximum number of submodels to return
//   - cursor: Pagination cursor for continuing from previous results
//   - query: Query object containing the filter condition
//
// Returns:
//   - gen.ImplResponse: Response containing paginated submodel results
//   - error: Error if the operation fails
func (s *SubmodelRepositoryAPIAPIService) QuerySubmodels(
	_ context.Context,
	limit int32,
	cursor string,
	query grammar.Query,
) (gen.ImplResponse, error) {
	// // Convert the grammar.Query to a QueryWrapper for the backend
	// queryWrapper := &grammar.QueryWrapper{
	// 	Query: query,
	// }

	// sms, nextCursor, err := s.submodelBackend.QuerySubmodels(limit, cursor, queryWrapper, false)
	// if err != nil {
	// 	log.Printf(" [%s] Error in QuerySubmodels: query failed (limit=%d cursor=%q): %v", smRepoComponentName, limit, cursor, err)
	// 	switch {
	// 	case common.IsErrBadRequest(err):
	// 		return common.NewErrorResponse(
	// 			err, http.StatusBadRequest, smRepoComponentName, "QuerySubmodels", "BadRequest",
	// 		), nil
	// 	default:
	// 		return common.NewErrorResponse(
	// 			err, http.StatusInternalServerError, smRepoComponentName, "QuerySubmodels", "InternalServerError",
	// 		), err
	// 	}
	// }

	// var converted []map[string]any
	// for _, sm := range sms {
	// 	jsonable, err := jsonization.ToJsonable(sm)
	// 	if err != nil {
	// 		log.Printf(" [%s] Error in QuerySubmodels: failed to convert submodel to jsonable: %v", smRepoComponentName, err)
	// 		return common.NewErrorResponse(
	// 			err, http.StatusInternalServerError, smRepoComponentName, "QuerySubmodels", "InternalServerError",
	// 		), err
	// 	}
	// 	converted = append(converted, jsonable)
	// }

	// // using the openAPI provided response struct to include paging metadata
	// res := gen.GetSubmodelsResult{
	// 	PagingMetadata: gen.PagedResultPagingMetadata{
	// 		Cursor: nextCursor,
	// 	},
	// 	Result: converted,
	// }
	return gen.Response(http.StatusOK, nil), nil
}
