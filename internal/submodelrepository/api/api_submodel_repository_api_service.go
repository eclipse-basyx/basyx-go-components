// Code generated by OpenAPI Generator (https://openapi-generator.tech);

/*
 * DotAAS Part 2 | HTTP/REST | Submodel Repository Service Specification
 *
 * The entire Submodel Repository Service Specification as part of the [Specification of the Asset Administration Shell: Part 2](http://industrialdigitaltwin.org/en/content-hub).   Publisher: Industrial Digital Twin Association (IDTA) 2023
 *
 * API version: V3.0.3_SSP-001
 * Contact: info@idtwin.org
 */

// Package api for the SubmodelRepositoryAPIAPI service
package api

import (
	"context"
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"os"
	"strings"

	"github.com/FriedJannik/aas-go-sdk/jsonization"
	"github.com/FriedJannik/aas-go-sdk/types"
	"github.com/eclipse-basyx/basyx-go-components/internal/common"
	gen "github.com/eclipse-basyx/basyx-go-components/internal/common/model"
	"github.com/eclipse-basyx/basyx-go-components/internal/common/model/grammar"
	persistencepostgresql "github.com/eclipse-basyx/basyx-go-components/internal/submodelrepository/persistence"
	openapi "github.com/eclipse-basyx/basyx-go-components/pkg/submodelrepositoryapi/go"
	"golang.org/x/sync/errgroup"
)

// SubmodelRepositoryAPIAPIService is a service that implements the logic for the SubmodelRepositoryAPIAPIServicer
// This service should implement the business logic for every endpoint for the SubmodelRepositoryAPIAPI API.
// Include any external packages or services that will be required by this service.
type SubmodelRepositoryAPIAPIService struct {
	submodelBackend persistencepostgresql.SubmodelDatabase
}

const componentName = "SMREPO"

// NewSubmodelRepositoryAPIAPIService creates a default api service
func NewSubmodelRepositoryAPIAPIService(databaseBackend persistencepostgresql.SubmodelDatabase) *SubmodelRepositoryAPIAPIService {
	return &SubmodelRepositoryAPIAPIService{
		submodelBackend: databaseBackend,
	}
}

func newAPIErrorResponse(err error, status int, operation string, info string) gen.ImplResponse {
	if err == nil {
		err = errors.New(http.StatusText(status))
	}

	return common.NewErrorResponse(err, status, componentName, operation, info)
}

func submodelValueToAnyMap(value gen.SubmodelValue) map[string]any {
	result := make(map[string]any, len(value))
	for key, val := range value {
		result[key] = val
	}
	return result
}

func decodeBase64RawStd(value string) (string, error) {
	if value == "" {
		return "", nil
	}

	decodedBytes, err := base64.RawStdEncoding.DecodeString(value)
	if err != nil {
		return "", err
	}

	return string(decodedBytes), nil
}

func encodeBase64RawStd(value string) string {
	if value == "" {
		return ""
	}

	return base64.RawStdEncoding.EncodeToString([]byte(value))
}

func buildLimitPtr(limit int32) *int {
	if limit <= 0 {
		return nil
	}

	parsedLimit := int(limit)
	return &parsedLimit
}

func mergeJSONObjects(base map[string]any, patch map[string]any) map[string]any {
	merged := make(map[string]any, len(base))
	for key, value := range base {
		merged[key] = value
	}

	for key, patchValue := range patch {
		if patchValue == nil {
			delete(merged, key)
			continue
		}

		baseValue, baseExists := merged[key]
		baseMap, baseIsMap := baseValue.(map[string]any)
		patchMap, patchIsMap := patchValue.(map[string]any)
		if baseExists && baseIsMap && patchIsMap {
			merged[key] = mergeJSONObjects(baseMap, patchMap)
			continue
		}

		merged[key] = patchValue
	}

	return merged
}

func toSubmodelElementMetadata(element types.ISubmodelElement) (gen.SubmodelElementMetadata, error) {
	jsonElement, err := jsonization.ToJsonable(element)
	if err != nil {
		return gen.SubmodelElementMetadata{}, err
	}

	payload, err := json.Marshal(jsonElement)
	if err != nil {
		return gen.SubmodelElementMetadata{}, err
	}

	metadata := gen.SubmodelElementMetadata{}
	if err := json.Unmarshal(payload, &metadata); err != nil {
		return gen.SubmodelElementMetadata{}, err
	}

	return metadata, nil
}

func getModelTypeLiteral(element types.ISubmodelElement) string {
	jsonElement, err := jsonization.ToJsonable(element)
	if err != nil {
		return ""
	}

	modelType, ok := jsonElement["modelType"].(string)
	if !ok {
		return ""
	}

	return modelType
}

// GetAllSubmodels retrieves all submodels from the repository with optional filtering and pagination.
// It supports filtering by idShort and provides pagination through cursor-based navigation.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - semanticID: Semantic identifier for filtering (currently unused)
//   - idShort: Short identifier for filtering submodels
//   - limit: Maximum number of submodels to return
//   - cursor: Pagination cursor for continuing from previous results
//   - level: Detail level for response (currently unused)
//   - extent: Response extent specification (currently unused)
//
// Returns:
//   - gen.ImplResponse: Response containing paginated submodel results
//   - error: Error if the operation fails
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodels(
	ctx context.Context,
	_ /*semanticID*/ string,
	idShort string,
	limit int32,
	cursor string,
	_ /*level*/ string,
	_ /*extent*/ string,
) (gen.ImplResponse, error) {
	const operation = "GetAllSubmodels"

	decodedCursor := ""
	if cursor != "" {
		decodedCursorBytes, decodeErr := base64.RawStdEncoding.DecodeString(cursor)
		if decodeErr != nil {
			return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "BadCursor"), nil
		}
		decodedCursor = string(decodedCursorBytes)
	}

	sms, nextCursor, err := s.submodelBackend.GetSubmodels(limit, decodedCursor, idShort)
	if err != nil {
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodels"), err
	}

	eg, _ := errgroup.WithContext(ctx)
	eg.SetLimit(8)

	for index := range sms {
		sm := sms[index]

		eg.Go(func() error {
			submodelElements, _, elementsErr := s.submodelBackend.GetSubmodelElements(sm.ID(), nil, "", false)
			if elementsErr != nil {
				return elementsErr
			}

			sm.SetSubmodelElements(submodelElements)
			return nil
		})
	}

	if waitErr := eg.Wait(); waitErr != nil {
		if common.IsErrNotFound(waitErr) || errors.Is(waitErr, sql.ErrNoRows) {
			return newAPIErrorResponse(waitErr, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		return newAPIErrorResponse(waitErr, http.StatusInternalServerError, operation, "GetSubmodelElements"), waitErr
	}

	converted := make([]map[string]any, 0, len(sms))

	for _, sm := range sms {
		jsonSubmodel, err := jsonization.ToJsonable(sm)
		if err != nil {
			return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "ToJsonable"), err
		}
		converted = append(converted, jsonSubmodel)
	}

	// using the openAPI provided response struct to include paging metadata
	encodedNextCursor := ""
	if nextCursor != "" {
		encodedNextCursor = base64.RawStdEncoding.EncodeToString([]byte(nextCursor))
	}

	res := gen.GetSubmodelsResult{
		PagingMetadata: gen.PagedResultPagingMetadata{
			Cursor: encodedNextCursor,
		},
		Result: converted,
	}
	return gen.Response(200, res), nil
}

// GetSubmodelByID retrieves a specific submodel by its base64-encoded identifier.
// The method decodes the identifier and fetches the submodel from the repository.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - id: Base64-encoded submodel identifier
//   - level: Detail level for response (currently unused)
//   - extent: Response extent specification (currently unused)
//
// Returns:
//   - gen.ImplResponse: Response containing the requested submodel
//   - error: Error if the submodel is not found or decoding fails
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelByID(
	_ /*ctx*/ context.Context,
	id string,
	_ /*level*/ string,
	_ /*extent*/ string,
) (gen.ImplResponse, error) {
	const operation = "GetSubmodelByID"

	decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(id)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	sm, err := s.submodelBackend.GetSubmodelByID(string(decodedSubmodelIdentifier))
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		if common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		_, _ = fmt.Printf("[DEBUG] GetSubmodelByID: Error getting submodel '%s': %v\n", string(decodedSubmodelIdentifier), err)
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelByID"), err
	}
	jsonSubmodel, err := jsonization.ToJsonable(sm)
	if err != nil {
		_, _ = fmt.Printf("[DEBUG] GetSubmodelByID: Error converting submodel '%s' to JSON: %v\n", string(decodedSubmodelIdentifier), err)
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "ToJsonable"), err
	}
	return gen.Response(200, jsonSubmodel), nil
}

// GetSignedSubmodelByID retrieves a signed submodel (JWS compact serialization) by its base64-encoded identifier.
func (s *SubmodelRepositoryAPIAPIService) GetSignedSubmodelByID(
	_ /*ctx*/ context.Context,
	id string,
	_ /*level*/ string,
	_ /*extent*/ string,
) (gen.ImplResponse, error) {
	const operation = "GetSignedSubmodelByID"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(id)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	jwsString, err := s.submodelBackend.GetSignedSubmodel(decodedSubmodelIdentifier, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		if err.Error() == "JWS signing not configured: private key not loaded" {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SigningNotConfigured"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSignedSubmodel"), err
	}

	return gen.Response(http.StatusOK, jwsString), nil
}

// GetSignedSubmodelByIDValueOnly retrieves a signed submodel in its Value-Only representation by its base64-encoded identifier.
func (s *SubmodelRepositoryAPIAPIService) GetSignedSubmodelByIDValueOnly(
	_ /*ctx*/ context.Context,
	id string,
	_ /*level*/ string,
	_ /*extent*/ string,
) (gen.ImplResponse, error) {
	const operation = "GetSignedSubmodelByIDValueOnly"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(id)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	jwsString, err := s.submodelBackend.GetSignedSubmodel(decodedSubmodelIdentifier, true)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		if err.Error() == "JWS signing not configured: private key not loaded" {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SigningNotConfigured"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSignedSubmodel"), err
	}

	return gen.Response(http.StatusOK, jwsString), nil
}

// DeleteSubmodelByID removes a submodel from the repository by its base64-encoded identifier.
// The method decodes the identifier and deletes the corresponding submodel.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - id: Base64-encoded submodel identifier
//
// Returns:
//   - gen.ImplResponse: Response indicating successful deletion
//   - error: Error if the submodel is not found or deletion fails
func (s *SubmodelRepositoryAPIAPIService) DeleteSubmodelByID(
	_ /*ctx*/ context.Context,
	id string,
) (gen.ImplResponse, error) {
	const operation = "DeleteSubmodelByID"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(id)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	err := s.submodelBackend.DeleteSubmodel(decodedSubmodelIdentifier)
	if err != nil {
		if common.IsErrNotFound(err) || errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "InternalServerError"), nil
	}

	return gen.Response(http.StatusNoContent, nil), nil
}

// PostSubmodel creates a new submodel in the repository.
// The method validates and persists the provided submodel data.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodel: The submodel data to create
//
// Returns:
//   - gen.ImplResponse: Response containing the created submodel (HTTP 201)
//   - error: Error if the creation fails
func (s *SubmodelRepositoryAPIAPIService) PostSubmodel(
	_ /*ctx*/ context.Context,
	submodel types.ISubmodel,
) (gen.ImplResponse, error) {
	const operation = "PostSubmodel"

	err := s.submodelBackend.CreateSubmodel(submodel)

	if err != nil {
		if common.IsErrConflict(err) {
			return newAPIErrorResponse(err, http.StatusConflict, operation, "IdConflict"), nil
		}

		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "InvalidSubmodelData"), nil
		}

		_, _ = fmt.Println("Error creating submodel: " + err.Error())

		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "CreateSubmodel"), err
	}

	submodelJsonable, err := jsonization.ToJsonable(submodel)
	if err != nil {
		return newAPIErrorResponse(err, http.StatusBadRequest, operation, "InvalidSubmodelData"), nil
	}

	return gen.Response(201, submodelJsonable), nil
}

// GetAllSubmodelsMetadata retrieves metadata attributes of all submodels.
// This method is currently not implemented and returns a not implemented error.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - semanticID: Semantic identifier for filtering
//   - idShort: Short identifier for filtering
//   - limit: Maximum number of results
//   - cursor: Pagination cursor
//
// Returns:
//   - gen.ImplResponse: Response with submodel metadata (when implemented)
//   - error: Currently returns "not implemented" error
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelsMetadata(
	_ /*ctx*/ context.Context,
	semanticID string,
	idShort string,
	limit int32,
	cursor string) (gen.ImplResponse, error) {
	const operation = "GetAllSubmodelsMetadata"

	decodedCursor := ""
	if cursor != "" {
		decodedCursorBytes, decodeErr := base64.RawStdEncoding.DecodeString(cursor)
		if decodeErr != nil {
			return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "BadCursor"), nil
		}
		decodedCursor = string(decodedCursorBytes)
	}

	submodels, nextCursor, err := s.submodelBackend.GetSubmodels(limit, decodedCursor, "")
	if err != nil {
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodels"), err
	}

	idShortFilter := strings.ToLower(strings.TrimSpace(idShort))
	semanticIDFilter := strings.ToLower(strings.TrimSpace(semanticID))

	converted := make([]map[string]any, 0, len(submodels))
	for _, sm := range submodels {
		if sm == nil {
			continue
		}

		if idShortFilter != "" {
			currentIDShort := ""
			if sm.IDShort() != nil {
				currentIDShort = strings.ToLower(*sm.IDShort())
			}
			if !strings.Contains(currentIDShort, idShortFilter) {
				continue
			}
		}

		if semanticIDFilter != "" {
			semanticRef := sm.SemanticID()
			if semanticRef == nil {
				continue
			}

			matchesSemanticID := false
			for _, key := range semanticRef.Keys() {
				if strings.Contains(strings.ToLower(key.Value()), semanticIDFilter) {
					matchesSemanticID = true
					break
				}
			}

			if !matchesSemanticID {
				continue
			}
		}

		jsonSubmodel, convertErr := jsonization.ToJsonable(sm)
		if convertErr != nil {
			return newAPIErrorResponse(convertErr, http.StatusInternalServerError, operation, "ToJsonable"), convertErr
		}
		delete(jsonSubmodel, "submodelElements")
		converted = append(converted, jsonSubmodel)
	}

	encodedCursor := ""
	if nextCursor != "" {
		encodedCursor = base64.RawStdEncoding.EncodeToString([]byte(nextCursor))
	}

	result := gen.GetSubmodelsMetadataResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodedCursor},
		Result:         converted,
	}

	return gen.Response(http.StatusOK, result), nil
}

// GetAllSubmodelsValueOnly - Returns all Submodels in their ValueOnly representation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelsValueOnly(ctx context.Context, semanticID string, idShort string, limit int32, cursor string, level string, extent string) (gen.ImplResponse, error) {
	_ = semanticID
	_ = level
	_ = extent
	const operation = "GetAllSubmodelsValueOnly"

	decodedCursor := ""
	if cursor != "" {
		decodedCursorBytes, decodeErr := base64.RawStdEncoding.DecodeString(cursor)
		if decodeErr != nil {
			return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "BadCursor"), nil
		}
		decodedCursor = string(decodedCursorBytes)
	}

	sms, nextCursor, err := s.submodelBackend.GetSubmodels(limit, decodedCursor, idShort)
	if err != nil {
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodels"), err
	}

	valueOnlyResults := make([]map[string]any, len(sms))

	eg, _ := errgroup.WithContext(ctx)
	eg.SetLimit(8)

	for index := range sms {
		index := index
		sm := sms[index]

		eg.Go(func() error {
			submodelElements, _, elementsErr := s.submodelBackend.GetSubmodelElements(sm.ID(), nil, "", false)
			if elementsErr != nil {
				return elementsErr
			}

			sm.SetSubmodelElements(submodelElements)

			valueOnly, convErr := gen.SubmodelToValueOnly(sm)
			if convErr != nil {
				return convErr
			}

			valueOnlyResults[index] = submodelValueToAnyMap(valueOnly)
			return nil
		})
	}

	if waitErr := eg.Wait(); waitErr != nil {
		if common.IsErrNotFound(waitErr) || errors.Is(waitErr, sql.ErrNoRows) {
			return newAPIErrorResponse(waitErr, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		return newAPIErrorResponse(waitErr, http.StatusInternalServerError, operation, "GetSubmodelElements"), waitErr
	}

	encodedNextCursor := ""
	if nextCursor != "" {
		encodedNextCursor = base64.RawStdEncoding.EncodeToString([]byte(nextCursor))
	}

	res := gen.GetSubmodelsValueResult{
		PagingMetadata: gen.PagedResultPagingMetadata{
			Cursor: encodedNextCursor,
		},
		Result: valueOnlyResults,
	}

	return gen.Response(http.StatusOK, res), nil
}

// GetAllSubmodelsReference - Returns the References for all Submodels
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelsReference(ctx context.Context, semanticID string, idShort string, limit int32, cursor string, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	const operation = "GetAllSubmodelsReference"

	decodedCursor, decodeErr := decodeBase64RawStd(cursor)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "BadCursor"), nil
	}

	decodedSemanticID := ""
	if semanticID != "" {
		decodedSemanticID, decodeErr = decodeBase64RawStd(semanticID)
		if decodeErr != nil {
			return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "BadSemanticID"), nil
		}
	}

	references, nextCursor, err := s.submodelBackend.GetSubmodelReferences(limit, decodedCursor, idShort, decodedSemanticID)
	if err != nil {
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelReferences"), err
	}

	var jsonReferences []map[string]any
	for _, ref := range references {
		jsonRef, err := jsonization.ToJsonable(ref)
		if err != nil {
			return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "ToJsonable"), err
		}
		jsonReferences = append(jsonReferences, jsonRef)
	}

	res := gen.GetReferencesResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodeBase64RawStd(nextCursor)},
		Result:         jsonReferences,
	}

	return gen.Response(http.StatusOK, res), nil
}

// GetAllSubmodelsPath - Returns all Submodels in the Path notation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelsPath(ctx context.Context, semanticID string, idShort string, limit int32, cursor string, level string) (gen.ImplResponse, error) {
	// TODO - update GetAllSubmodelsPath with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, GetPathItemsResult{}) or use other options such as http.Ok ...
	// return gen.Response(200, GetPathItemsResult{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("GetAllSubmodelsPath method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "GetAllSubmodelsPath", "NotImplemented"), nil
}

// PutSubmodelByID - Updates an existing Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PutSubmodelByID(ctx context.Context, submodelIdentifier string, submodel types.ISubmodel) (gen.ImplResponse, error) {
	_ = ctx
	const operation = "PutSubmodelByID"

	decodedIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	if decodedIdentifier != submodel.ID() {
		return newAPIErrorResponse(errors.New("submodel ID in path and body do not match"), http.StatusBadRequest, operation, "IdMismatch"), nil
	}

	isUpdate, err := s.submodelBackend.PutSubmodel(decodedIdentifier, submodel)
	if err != nil {
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		if common.IsErrConflict(err) {
			return newAPIErrorResponse(err, http.StatusConflict, operation, "Conflict"), nil
		}
		if common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "InternalServerError"), nil
	}

	if isUpdate {
		return gen.Response(http.StatusNoContent, nil), nil
	}

	jsonSubmodel, jsonErr := jsonization.ToJsonable(submodel)
	if jsonErr != nil {
		return newAPIErrorResponse(jsonErr, http.StatusBadRequest, operation, "InvalidSubmodelData"), nil
	}

	return gen.Response(http.StatusCreated, jsonSubmodel), nil
}

// PatchSubmodelByID - Updates an existing Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelByID(ctx context.Context, submodelIdentifier string, submodel types.ISubmodel, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	const operation = "PatchSubmodelByID"

	decodedIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	if submodel == nil {
		return newAPIErrorResponse(errors.New("submodel payload is required"), http.StatusBadRequest, operation, "MissingSubmodelPayload"), nil
	}

	if submodel.ID() != "" && decodedIdentifier != submodel.ID() {
		return newAPIErrorResponse(errors.New("submodel ID in path and body do not match"), http.StatusBadRequest, operation, "IdMismatch"), nil
	}

	patchJSON, patchJSONErr := jsonization.ToJsonable(submodel)
	if patchJSONErr != nil {
		return newAPIErrorResponse(patchJSONErr, http.StatusBadRequest, operation, "InvalidSubmodelData"), nil
	}

	_, patchIncludesSubmodelElements := patchJSON["submodelElements"]

	existingSubmodels, _, getErr := s.submodelBackend.GetSubmodels(1, "", decodedIdentifier)
	if getErr != nil {
		if common.IsErrNotFound(getErr) || errors.Is(getErr, sql.ErrNoRows) {
			return newAPIErrorResponse(getErr, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}

		return newAPIErrorResponse(getErr, http.StatusInternalServerError, operation, "GetSubmodelByID"), getErr
	}

	if len(existingSubmodels) == 0 {
		return newAPIErrorResponse(common.NewErrNotFound(decodedIdentifier), http.StatusNotFound, operation, "SubmodelNotFound"), nil
	}

	existingSubmodel := existingSubmodels[0]
	if existingSubmodel == nil {
		nilErr := common.NewInternalServerError("SMREPO-PATCHSM-EXISTINGNIL Existing submodel is nil")
		return newAPIErrorResponse(nilErr, http.StatusInternalServerError, operation, "GetSubmodelByID"), nilErr
	}

	existingJSON, existingJSONErr := jsonization.ToJsonable(existingSubmodel)
	if existingJSONErr != nil {
		return newAPIErrorResponse(existingJSONErr, http.StatusInternalServerError, operation, "ToJsonableCurrentSubmodel"), existingJSONErr
	}

	patchJSON["id"] = decodedIdentifier

	mergedJSON := mergeJSONObjects(existingJSON, patchJSON)

	mergedSubmodel, mergedErr := jsonization.SubmodelFromJsonable(mergedJSON)
	if mergedErr != nil {
		return newAPIErrorResponse(mergedErr, http.StatusBadRequest, operation, "InvalidPatchedSubmodel"), nil
	}

	err := error(nil)
	if patchIncludesSubmodelElements {
		err = s.submodelBackend.PatchSubmodel(decodedIdentifier, mergedSubmodel)
	} else {
		err = s.submodelBackend.PatchSubmodelMetadata(decodedIdentifier, mergedSubmodel)
	}
	if err != nil {
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		if common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}

		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "InternalServerError"), nil
	}

	return gen.Response(http.StatusNoContent, nil), nil
}

// GetSubmodelByIDMetadata - Returns the metadata attributes of a specific Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelByIDMetadata(ctx context.Context, submodelIdentifier string) (gen.ImplResponse, error) {
	// TODO - update GetSubmodelByIDMetadata with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, SubmodelMetadata{}) or use other options such as http.Ok ...
	// return gen.Response(200, SubmodelMetadata{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("GetSubmodelByIDMetadata method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "GetSubmodelByIDMetadata", "NotImplemented"), nil
}

// PatchSubmodelByIDMetadata - Updates the metadata attributes of an existing Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelByIDMetadata(ctx context.Context, submodelIdentifier string, submodelMetadata gen.SubmodelMetadata) (gen.ImplResponse, error) {
	// TODO - update PatchSubmodelByIDMetadata with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return gen.Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("PatchSubmodelByIDMetadata method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "PatchSubmodelByIDMetadata", "NotImplemented"), nil
}

// GetSubmodelByIDValueOnly - Returns a specific Submodel in the ValueOnly representation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelByIDValueOnly(ctx context.Context, submodelIdentifier string, level string, extent string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	_ = extent
	const operation = "GetSubmodelByIDValueOnly"

	decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	sm, err := s.submodelBackend.GetSubmodelByID(string(decodedSubmodelIdentifier))
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelByID"), err
	}

	valueOnly, convErr := gen.SubmodelToValueOnly(sm)
	if convErr != nil {
		return newAPIErrorResponse(convErr, http.StatusInternalServerError, operation, "SubmodelToValueOnly"), convErr
	}

	return gen.Response(http.StatusOK, valueOnly), nil
}

// PatchSubmodelByIDValueOnly - Updates the values of an existing Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelByIDValueOnly(ctx context.Context, submodelIdentifier string, body gen.SubmodelValue, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	const operation = "PatchSubmodelByIDValueOnly"

	decodedIdentifier, err := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if err != nil {
		return newAPIErrorResponse(err, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	err = s.submodelBackend.UpdateSubmodelValueOnly(string(decodedIdentifier), body)
	if err != nil {
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		if common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, fmt.Sprintf("SubmodelOrSubmodelElementNotFound-%s", decodedIdentifier)), nil
		}
		_, _ = fmt.Println(err)
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "InternalServerError"), nil
	}
	return gen.Response(http.StatusNoContent, nil), nil
}

// GetSubmodelByIDReference - Returns the Reference of a specific Submodel
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelByIDReference(ctx context.Context, submodelIdentifier string) (gen.ImplResponse, error) {
	_ = ctx
	const operation = "GetSubmodelByIDReference"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	reference, err := s.submodelBackend.GetSubmodelReference(decodedSubmodelIdentifier)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelReference"), err
	}

	jsonableRef, convErr := jsonization.ToJsonable(reference)
	if convErr != nil {
		return newAPIErrorResponse(convErr, http.StatusInternalServerError, operation, "ToJsonable"), convErr
	}

	return gen.Response(http.StatusOK, jsonableRef), nil
}

// GetSubmodelByIDPath - Returns a specific Submodel in the Path notation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelByIDPath(ctx context.Context, submodelIdentifier string, level string) (gen.ImplResponse, error) {
	// TODO - update GetSubmodelByIDPath with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, []string{}) or use other options such as http.Ok ...
	// return gen.Response(200, []string{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("GetSubmodelByIDPath method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "GetSubmodelByIDPath", "NotImplemented"), nil
}

// GetAllSubmodelElements retrieves all submodel elements from a specific submodel including their hierarchy.
// The method supports pagination and different detail levels for the response.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodelIdentifier: Base64-encoded identifier of the parent submodel
//   - limit: Maximum number of elements to return
//   - cursor: Pagination cursor
//   - level: Detail level for response
//   - extent: Response extent specification
//
// Returns:
//   - gen.ImplResponse: Response containing submodel elements
//   - error: Error if the operation fails
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelElements(_ /*ctx*/ context.Context, submodelIdentifier string, limit int32, cursor string, _ /*level*/ string, _ /*extent*/ string) (gen.ImplResponse, error) {
	const operation = "GetAllSubmodelElements"

	decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	decodedCursor := ""
	if cursor != "" {
		decodedCursorBytes, err := base64.RawStdEncoding.DecodeString(cursor)
		if err != nil {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadCursor"), nil
		}
		decodedCursor = string(decodedCursorBytes)
	}

	var limitPtr *int
	if limit > 0 {
		parsedLimit := int(limit)
		limitPtr = &parsedLimit
	}

	elements, nextCursor, err := s.submodelBackend.GetSubmodelElements(string(decodedSubmodelIdentifier), limitPtr, decodedCursor, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElements"), err
	}

	converted := make([]map[string]any, 0, len(elements))
	for _, element := range elements {
		jsonSubmodelElement, convErr := jsonization.ToJsonable(element)
		if convErr != nil {
			return newAPIErrorResponse(convErr, http.StatusInternalServerError, operation, "ToJsonable"), convErr
		}
		converted = append(converted, jsonSubmodelElement)
	}

	encodedNextCursor := ""
	if nextCursor != "" {
		encodedNextCursor = base64.RawStdEncoding.EncodeToString([]byte(nextCursor))
	}

	res := gen.GetSubmodelElementsResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodedNextCursor},
		Result:         converted,
	}

	return gen.Response(http.StatusOK, res), nil
}

// PostSubmodelElementSubmodelRepo creates a new submodel element within a specified submodel.
// The method validates and persists the provided submodel element data.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodelIdentifier: Base64-encoded identifier of the parent submodel
//   - submodelElement: The submodel element data to create
//
// Returns:
//   - gen.ImplResponse: Response containing the created submodel element (HTTP 201)
//   - error: Error if the creation fails
func (s *SubmodelRepositoryAPIAPIService) PostSubmodelElementSubmodelRepo(_ /*ctx*/ context.Context, submodelIdentifier string, submodelElement types.ISubmodelElement) (gen.ImplResponse, error) {
	const operation = "PostSubmodelElementSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	if err := s.submodelBackend.AddSubmodelElement(decodedSubmodelIdentifier, submodelElement); err != nil {
		if common.IsErrNotFound(err) || errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		if common.IsErrConflict(err) {
			return newAPIErrorResponse(err, http.StatusConflict, operation, "Conflict"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "AddSubmodelElement"), err
	}

	return gen.Response(http.StatusCreated, submodelElement), nil
}

// GetAllSubmodelElementsMetadataSubmodelRepo - Returns the metadata attributes of all submodel elements including their hierarchy
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelElementsMetadataSubmodelRepo(ctx context.Context, submodelIdentifier string, limit int32, cursor string) (gen.ImplResponse, error) {
	_ = ctx
	const operation = "GetAllSubmodelElementsMetadataSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	decodedCursor, cursorDecodeErr := decodeBase64RawStd(cursor)
	if cursorDecodeErr != nil {
		return newAPIErrorResponse(cursorDecodeErr, http.StatusBadRequest, operation, "BadCursor"), nil
	}

	elements, nextCursor, err := s.submodelBackend.GetSubmodelElements(decodedSubmodelIdentifier, buildLimitPtr(limit), decodedCursor, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElements"), err
	}

	metadataResult := make([]gen.SubmodelElementMetadata, 0, len(elements))
	for _, element := range elements {
		metadata, conversionErr := toSubmodelElementMetadata(element)
		if conversionErr != nil {
			return newAPIErrorResponse(conversionErr, http.StatusInternalServerError, operation, "ToSubmodelElementMetadata"), conversionErr
		}
		metadataResult = append(metadataResult, metadata)
	}

	res := gen.GetSubmodelElementsMetadataResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodeBase64RawStd(nextCursor)},
		Result:         metadataResult,
	}

	return gen.Response(http.StatusOK, res), nil
}

// GetAllSubmodelElementsValueOnlySubmodelRepo - Returns all submodel elements including their hierarchy in the ValueOnly representation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelElementsValueOnlySubmodelRepo(ctx context.Context, submodelIdentifier string, limit int32, cursor string, level string, extent string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	_ = extent
	const operation = "GetAllSubmodelElementsValueOnlySubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	decodedCursor := ""
	if cursor != "" {
		decodedCursorBytes, err := base64.RawStdEncoding.DecodeString(cursor)
		if err != nil {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadCursor"), nil
		}
		decodedCursor = string(decodedCursorBytes)
	}

	var limitPtr *int
	if limit > 0 {
		parsedLimit := int(limit)
		limitPtr = &parsedLimit
	}

	elements, nextCursor, err := s.submodelBackend.GetSubmodelElements(string(decodedSubmodelIdentifier), limitPtr, decodedCursor, true)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElements"), err
	}

	valueOnlyResults := make([]gen.SubmodelElementValue, 0, len(elements))
	for _, element := range elements {
		valueOnly, convErr := gen.SubmodelElementToValueOnly(element)
		if convErr != nil {
			return newAPIErrorResponse(convErr, http.StatusInternalServerError, operation, "SubmodelElementToValueOnly"), convErr
		}
		if valueOnly == nil {
			continue
		}

		idShort := element.IDShort()
		if idShort == nil || *idShort == "" {
			continue
		}

		wrapped := make(gen.SubmodelElementCollectionValue)
		wrapped[*idShort] = valueOnly
		valueOnlyResults = append(valueOnlyResults, wrapped)
	}

	encodedNextCursor := ""
	if nextCursor != "" {
		encodedNextCursor = base64.RawStdEncoding.EncodeToString([]byte(nextCursor))
	}

	res := gen.GetSubmodelElementsValueResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodedNextCursor},
		Result:         valueOnlyResults,
	}

	return gen.Response(http.StatusOK, res), nil
}

// GetAllSubmodelElementsReferenceSubmodelRepo - Returns the References of all submodel elements
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelElementsReferenceSubmodelRepo(ctx context.Context, submodelIdentifier string, limit int32, cursor string, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	const operation = "GetAllSubmodelElementsReferenceSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	decodedCursor, cursorDecodeErr := decodeBase64RawStd(cursor)
	if cursorDecodeErr != nil {
		return newAPIErrorResponse(cursorDecodeErr, http.StatusBadRequest, operation, "BadCursor"), nil
	}

	references, nextCursor, err := s.submodelBackend.GetSubmodelElementReferences(decodedSubmodelIdentifier, buildLimitPtr(limit), decodedCursor)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElementReferences"), err
	}

	jsonableArray := make([]map[string]any, 0, len(references))
	for _, ref := range references {
		jsonRef, convErr := jsonization.ToJsonable(ref)
		if convErr != nil {
			return newAPIErrorResponse(convErr, http.StatusInternalServerError, operation, "ToJsonable"), convErr
		}
		jsonableArray = append(jsonableArray, jsonRef)
	}

	res := gen.GetReferencesResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodeBase64RawStd(nextCursor)},
		Result:         jsonableArray,
	}

	return gen.Response(http.StatusOK, res), nil
}

// GetAllSubmodelElementsPathSubmodelRepo - Returns all submodel elements including their hierarchy in the Path notation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetAllSubmodelElementsPathSubmodelRepo(ctx context.Context, submodelIdentifier string, limit int32, cursor string, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	const operation = "GetAllSubmodelElementsPathSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	decodedCursor, cursorDecodeErr := decodeBase64RawStd(cursor)
	if cursorDecodeErr != nil {
		return newAPIErrorResponse(cursorDecodeErr, http.StatusBadRequest, operation, "BadCursor"), nil
	}

	elements, nextCursor, err := s.submodelBackend.GetSubmodelElements(decodedSubmodelIdentifier, buildLimitPtr(limit), decodedCursor, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElements"), err
	}

	paths := make([]string, 0, len(elements))
	for _, element := range elements {
		idShort := element.IDShort()
		if idShort == nil || *idShort == "" {
			continue
		}
		paths = append(paths, *idShort)
	}

	res := gen.GetPathItemsResult{
		PagingMetadata: gen.PagedResultPagingMetadata{Cursor: encodeBase64RawStd(nextCursor)},
		Result:         paths,
	}

	return gen.Response(http.StatusOK, res), nil
}

// GetSubmodelElementByPathSubmodelRepo - Returns a specific submodel element from the Submodel at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelElementByPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, level string, extent string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	_ = extent
	const operation = "GetSubmodelElementByPathSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	element, err := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, idShortPath, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElement"), err
	}

	converted, convErr := jsonization.ToJsonable(element)
	if convErr != nil {
		return newAPIErrorResponse(convErr, http.StatusInternalServerError, operation, "ToJsonable"), convErr
	}

	return gen.Response(http.StatusOK, converted), nil
}

// PutSubmodelElementByPathSubmodelRepo updates an existing submodel element at a specified path within submodel elements hierarchy.
// The method replaces the existing element with the provided data.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodelIdentifier: Base64-encoded identifier of the parent submodel
//   - idShortPath: Path to the target submodel element
//   - submodelElement: Updated submodel element data
//   - level: Detail level for response
//
// Returns:
//   - gen.ImplResponse: Response indicating successful update (HTTP 204)
//   - error: Error if the update fails
func (s *SubmodelRepositoryAPIAPIService) PutSubmodelElementByPathSubmodelRepo(_ /*ctx*/ context.Context, submodelIdentifier string, idShortPath string, submodelElement types.ISubmodelElement, _ /*level*/ string) (gen.ImplResponse, error) {
	const operation = "PutSubmodelElementByPathSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	err := s.submodelBackend.UpdateSubmodelElement(decodedSubmodelIdentifier, idShortPath, submodelElement, true)
	if err != nil {
		if common.IsErrNotFound(err) || errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		if common.IsErrConflict(err) {
			return newAPIErrorResponse(err, http.StatusConflict, operation, "Conflict"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "UpdateSubmodelElement"), err
	}

	return gen.Response(http.StatusNoContent, nil), nil
}

// PostSubmodelElementByPathSubmodelRepo creates a new submodel element at a specified path within submodel elements hierarchy.
// The method creates a nested element under the specified path.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodelIdentifier: Base64-encoded identifier of the parent submodel
//   - idShortPath: Path where the new element should be created
//   - submodelElement: The submodel element data to create
//
// Returns:
//   - gen.ImplResponse: Response containing the created submodel element (HTTP 201)
//   - error: Error if the creation fails
func (s *SubmodelRepositoryAPIAPIService) PostSubmodelElementByPathSubmodelRepo(_ /*ctx*/ context.Context, submodelIdentifier string, idShortPath string, submodelElement types.ISubmodelElement) (gen.ImplResponse, error) {
	const operation = "PostSubmodelElementByPathSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	err := s.submodelBackend.AddSubmodelElementWithPath(decodedSubmodelIdentifier, idShortPath, submodelElement)
	if err != nil {
		if common.IsErrNotFound(err) || errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "ParentOrSubmodelNotFound"), nil
		}
		if common.IsErrConflict(err) {
			return newAPIErrorResponse(err, http.StatusConflict, operation, "Conflict"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "AddSubmodelElementWithPath"), err
	}

	return gen.Response(http.StatusCreated, submodelElement), nil
}

// DeleteSubmodelElementByPathSubmodelRepo deletes a submodel element at a specified path within the submodel elements hierarchy.
// The method removes the element and all its children from the specified path.
//
// Parameters:
//   - ctx: Request context (currently unused)
//   - submodelIdentifier: Base64-encoded identifier of the parent submodel
//   - idShortPath: Path to the submodel element to delete
//
// Returns:
//   - gen.ImplResponse: Response indicating successful deletion (HTTP 204)
//   - error: Error if the deletion fails
func (s *SubmodelRepositoryAPIAPIService) DeleteSubmodelElementByPathSubmodelRepo(_ /*ctx*/ context.Context, submodelIdentifier string, idShortPath string) (gen.ImplResponse, error) {
	const operation = "DeleteSubmodelElementByPathSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	err := s.submodelBackend.DeleteSubmodelElementByPath(decodedSubmodelIdentifier, idShortPath)
	if err != nil {
		if common.IsErrNotFound(err) || errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "DeleteSubmodelElementByPath"), err
	}

	return gen.Response(http.StatusNoContent, nil), nil
}

// PatchSubmodelElementByPathSubmodelRepo - Updates an existing SubmodelElement
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelElementByPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, submodelElement types.ISubmodelElement, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	const operation = "PatchSubmodelElementByPathSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	if submodelElement == nil {
		return newAPIErrorResponse(errors.New("submodel element payload is required"), http.StatusBadRequest, operation, "MissingSubmodelElementPayload"), nil
	}

	existingElement, getErr := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, idShortPath, false)
	if getErr != nil {
		if common.IsErrNotFound(getErr) || errors.Is(getErr, sql.ErrNoRows) {
			return newAPIErrorResponse(getErr, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}

		return newAPIErrorResponse(getErr, http.StatusInternalServerError, operation, "GetSubmodelElement"), getErr
	}

	existingJSON, existingJSONErr := jsonization.ToJsonable(existingElement)
	if existingJSONErr != nil {
		return newAPIErrorResponse(existingJSONErr, http.StatusInternalServerError, operation, "ToJsonableCurrentSubmodelElement"), existingJSONErr
	}

	patchJSON, patchJSONErr := jsonization.ToJsonable(submodelElement)
	if patchJSONErr != nil {
		return newAPIErrorResponse(patchJSONErr, http.StatusBadRequest, operation, "InvalidSubmodelElementData"), nil
	}

	mergedJSON := mergeJSONObjects(existingJSON, patchJSON)
	if _, hasValuePatch := patchJSON["value"]; !hasValuePatch {
		delete(mergedJSON, "value")
	}

	mergedElement, mergedErr := jsonization.SubmodelElementFromJsonable(mergedJSON)
	if mergedErr != nil {
		return newAPIErrorResponse(mergedErr, http.StatusBadRequest, operation, "InvalidPatchedSubmodelElement"), nil
	}

	err := s.submodelBackend.UpdateSubmodelElement(decodedSubmodelIdentifier, idShortPath, mergedElement, false)
	if err != nil {
		if common.IsErrNotFound(err) || errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		if common.IsErrConflict(err) {
			return newAPIErrorResponse(err, http.StatusConflict, operation, "Conflict"), nil
		}

		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "UpdateSubmodelElement"), err
	}

	return gen.Response(http.StatusNoContent, nil), nil
}

// GetSubmodelElementByPathMetadataSubmodelRepo - Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelElementByPathMetadataSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string) (gen.ImplResponse, error) {
	_ = ctx
	const operation = "GetSubmodelElementByPathMetadataSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	element, err := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, idShortPath, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElement"), err
	}

	metadata, conversionErr := toSubmodelElementMetadata(element)
	if conversionErr != nil {
		return newAPIErrorResponse(conversionErr, http.StatusInternalServerError, operation, "ToSubmodelElementMetadata"), conversionErr
	}

	return gen.Response(http.StatusOK, metadata), nil
}

// PatchSubmodelElementByPathMetadataSubmodelRepo - Updates the metadata attributes an existing SubmodelElement
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelElementByPathMetadataSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, submodelElementMetadata gen.SubmodelElementMetadata) (gen.ImplResponse, error) {
	// TODO - update PatchSubmodelElementByPathMetadataSubmodelRepo with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	// return gen.Response(204, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("PatchSubmodelElementByPathMetadataSubmodelRepo method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "PatchSubmodelElementByPathMetadataSubmodelRepo", "NotImplemented"), nil
}

// GetSubmodelElementByPathValueOnlySubmodelRepo - Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelElementByPathValueOnlySubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, level string, extent string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	_ = extent
	const operation = "GetSubmodelElementByPathValueOnlySubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	element, err := s.submodelBackend.GetSubmodelElement(string(decodedSubmodelIdentifier), idShortPath, true)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElement"), err
	}

	valueOnly, convErr := gen.SubmodelElementToValueOnly(element)
	if convErr != nil {
		return newAPIErrorResponse(convErr, http.StatusInternalServerError, operation, "SubmodelElementToValueOnly"), convErr
	}

	if valueOnly == nil {
		notSerializableErr := errors.New("element cannot be serialized in value-only format")
		return newAPIErrorResponse(notSerializableErr, http.StatusNotFound, operation, "ValueOnlyNotSupported"), nil
	}

	return gen.Response(http.StatusOK, valueOnly), nil
}

// PatchSubmodelElementByPathValueOnlySubmodelRepo - Updates the value of an existing SubmodelElement
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PatchSubmodelElementByPathValueOnlySubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, submodelElementValue gen.SubmodelElementValue, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	const operation = "PatchSubmodelElementByPathValueOnlySubmodelRepo"

	decodedIdentifier, decodeErr := base64.RawStdEncoding.DecodeString(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	err := s.submodelBackend.UpdateSubmodelElementValueOnly(string(decodedIdentifier), idShortPath, submodelElementValue)
	if err != nil {
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		if common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "UpdateSubmodelElementValueOnly"), nil
	}

	return gen.Response(http.StatusNoContent, nil), nil
}

// GetSubmodelElementByPathReferenceSubmodelRepo - Returns the Referee of a specific submodel element from the Submodel at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelElementByPathReferenceSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string) (gen.ImplResponse, error) {
	_ = ctx
	const operation = "GetSubmodelElementByPathReferenceSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	element, err := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, idShortPath, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElement"), err
	}

	modelTypeLiteral := getModelTypeLiteral(element)
	if modelTypeLiteral == "" {
		internalErr := common.NewInternalServerError("SMREPO-GETSMEREF-MODELTYPE Empty modelType for submodel element")
		return newAPIErrorResponse(internalErr, http.StatusInternalServerError, operation, "EmptyModelType"), internalErr
	}

	keyTypes, keyValues, keyResolutionErr := resolveModelReferencePathKeys(
		idShortPath,
		modelTypeLiteral,
		func(path string) (string, error) {
			parentElement, parentErr := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, path, false)
			if parentErr != nil {
				if common.IsErrBadRequest(parentErr) || common.IsErrNotFound(parentErr) {
					return "", parentErr
				}
				return "", common.NewInternalServerError("SMREPO-BUILDREF-GETPARENT " + parentErr.Error())
			}

			parentModelType := getModelTypeLiteral(parentElement)
			if parentModelType == "" {
				return "", common.NewInternalServerError("SMREPO-BUILDREF-PARENTMODELTYPE Empty modelType for parent submodel element")
			}

			return parentModelType, nil
		},
	)
	if keyResolutionErr != nil {
		if common.IsErrBadRequest(keyResolutionErr) {
			return newAPIErrorResponse(keyResolutionErr, http.StatusBadRequest, operation, "BadReferencePath"), nil
		}
		if common.IsErrNotFound(keyResolutionErr) {
			return newAPIErrorResponse(keyResolutionErr, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		return newAPIErrorResponse(keyResolutionErr, http.StatusInternalServerError, operation, "ResolveReferenceKeys"), keyResolutionErr
	}

	reference, referenceErr := buildModelReference(decodedSubmodelIdentifier, keyTypes, keyValues)
	if referenceErr != nil {
		return newAPIErrorResponse(referenceErr, http.StatusInternalServerError, operation, "BuildModelReference"), referenceErr
	}

	var jsonableRef map[string]any
	if reference != nil {
		jsonableRef, err = jsonization.ToJsonable(reference)
		if err != nil {
			return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "ToJsonable"), err
		}
	}

	return gen.Response(http.StatusOK, jsonableRef), nil
}

// GetSubmodelElementByPathPathSubmodelRepo - Returns a specific submodel element from the Submodel at a specified path in the Path notation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetSubmodelElementByPathPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, level string) (gen.ImplResponse, error) {
	_ = ctx
	_ = level
	const operation = "GetSubmodelElementByPathPathSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	_, err := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, idShortPath, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || common.IsErrNotFound(err) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElement"), err
	}

	return gen.Response(http.StatusOK, []string{idShortPath}), nil
}

// GetFileByPathSubmodelRepo - Downloads file content from a specific submodel element from the Submodel at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetFileByPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string) (gen.ImplResponse, error) {
	_ = ctx
	const operation = "GetFileByPathSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	fileSme, err := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, idShortPath, false)
	if err != nil {
		if common.IsErrNotFound(err) || errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElement"), err
	}

	fileValue, ok := fileSme.(*types.File)
	if !ok {
		notFileErr := common.NewErrBadRequest("SMREPO-GETFILEBYPATH-NOTFILE Submodel element is not of type File")
		return newAPIErrorResponse(notFileErr, http.StatusBadRequest, operation, "ElementNotAFile"), nil
	}

	fileURL := fileValue.Value()
	if fileURL == nil || *fileURL == "" {
		notFoundErr := common.NewErrNotFound("SMREPO-GETFILEBYPATH-EMPTYURL File URL is empty")
		return newAPIErrorResponse(notFoundErr, http.StatusNotFound, operation, "EmptyFileUrl"), nil
	}

	if strings.HasPrefix(*fileURL, "http://") || strings.HasPrefix(*fileURL, "https://") {
		return gen.Response(http.StatusFound, openapi.Redirect{Location: *fileURL}), nil
	}

	fileContent, contentType, fileName, err := s.submodelBackend.DownloadFileAttachment(decodedSubmodelIdentifier, idShortPath)
	if err != nil {
		if common.IsErrNotFound(err) || errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "FileNotFound"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "DownloadFileAttachment"), err
	}

	return gen.Response(http.StatusOK, openapi.FileDownload{
		Content:     fileContent,
		ContentType: contentType,
		Filename:    fileName,
	}), nil
}

// PutFileByPathSubmodelRepo - Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) PutFileByPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, fileName string, file *os.File) (gen.ImplResponse, error) {
	_ = ctx
	const operation = "PutFileByPathSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	fileSme, err := s.submodelBackend.GetSubmodelElement(decodedSubmodelIdentifier, idShortPath, false)
	if err != nil {
		if common.IsErrNotFound(err) || errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "GetSubmodelElement"), err
	}

	if _, ok := fileSme.(*types.File); !ok {
		notFileErr := common.NewErrBadRequest("SMREPO-PUTFILEBYPATH-NOTFILE Submodel element is not of type File")
		return newAPIErrorResponse(notFileErr, http.StatusBadRequest, operation, "ElementNotAFile"), nil
	}

	err = s.submodelBackend.UploadFileAttachment(decodedSubmodelIdentifier, idShortPath, file, fileName)
	if err != nil {
		if common.IsErrNotFound(err) || errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "UploadFileAttachment"), err
	}

	return gen.Response(http.StatusNoContent, nil), nil
}

// DeleteFileByPathSubmodelRepo - Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) DeleteFileByPathSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string) (gen.ImplResponse, error) {
	_ = ctx
	const operation = "DeleteFileByPathSubmodelRepo"

	decodedSubmodelIdentifier, decodeErr := decodeBase64RawStd(submodelIdentifier)
	if decodeErr != nil {
		return newAPIErrorResponse(decodeErr, http.StatusBadRequest, operation, "MalformedSubmodelIdentifier"), nil
	}

	err := s.submodelBackend.DeleteFileAttachment(decodedSubmodelIdentifier, idShortPath)
	if err != nil {
		if common.IsErrNotFound(err) || errors.Is(err, sql.ErrNoRows) {
			return newAPIErrorResponse(err, http.StatusNotFound, operation, "SubmodelElementNotFound"), nil
		}
		if common.IsErrBadRequest(err) {
			return newAPIErrorResponse(err, http.StatusBadRequest, operation, "BadRequest"), nil
		}
		return newAPIErrorResponse(err, http.StatusInternalServerError, operation, "DeleteFileAttachment"), err
	}

	return gen.Response(http.StatusOK, nil), nil
}

// InvokeOperationSubmodelRepo - Synchronously or asynchronously invokes an Operation at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) InvokeOperationSubmodelRepo(ctx context.Context, submodelIdentifier string, idShortPath string, operationRequest gen.OperationRequest, async bool) (gen.ImplResponse, error) {
	// TODO - update InvokeOperationSubmodelRepo with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, OperationResult{}) or use other options such as http.Ok ...
	// return gen.Response(200, OperationResult{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(405, Result{}) or use other options such as http.Ok ...
	// return gen.Response(405, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("InvokeOperationSubmodelRepo method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "InvokeOperationSubmodelRepo", "NotImplemented"), nil
}

// InvokeOperationValueOnly - Synchronously or asynchronously invokes an Operation at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) InvokeOperationValueOnly(ctx context.Context, aasIdentifier string, submodelIdentifier string, idShortPath string, operationRequestValueOnly gen.OperationRequestValueOnly, async bool) (gen.ImplResponse, error) {
	// TODO - update InvokeOperationValueOnly with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, OperationResultValueOnly{}) or use other options such as http.Ok ...
	// return gen.Response(200, OperationResultValueOnly{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("InvokeOperationValueOnly method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "InvokeOperationValueOnly", "NotImplemented"), nil
}

// InvokeOperationAsync - Asynchronously invokes an Operation at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) InvokeOperationAsync(ctx context.Context, submodelIdentifier string, idShortPath string, operationRequest gen.OperationRequest) (gen.ImplResponse, error) {
	// TODO - update InvokeOperationAsync with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(202, {}) or use other options such as http.Ok ...
	// return gen.Response(202, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(405, Result{}) or use other options such as http.Ok ...
	// return gen.Response(405, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("InvokeOperationAsync method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "InvokeOperationAsync", "NotImplemented"), nil
}

// InvokeOperationAsyncValueOnly - Asynchronously invokes an Operation at a specified path
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) InvokeOperationAsyncValueOnly(ctx context.Context, aasIdentifier string, submodelIdentifier string, idShortPath string, operationRequestValueOnly gen.OperationRequestValueOnly) (gen.ImplResponse, error) {
	// TODO - update InvokeOperationAsyncValueOnly with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(202, {}) or use other options such as http.Ok ...
	// return gen.Response(202, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("InvokeOperationAsyncValueOnly method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "InvokeOperationAsyncValueOnly", "NotImplemented"), nil
}

// GetOperationAsyncStatus - Returns the status of an asynchronously invoked Operation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetOperationAsyncStatus(ctx context.Context, submodelIdentifier string, idShortPath string, handleID string) (gen.ImplResponse, error) {
	// TODO - update GetOperationAsyncStatus with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, BaseOperationResult{}) or use other options such as http.Ok ...
	// return gen.Response(200, BaseOperationResult{}), nil

	// TODO: Uncomment the next line to return response Response(302, {}) or use other options such as http.Ok ...
	// return gen.Response(302, nil),nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("GetOperationAsyncStatus method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "GetOperationAsyncStatus", "NotImplemented"), nil
}

// GetOperationAsyncResult - Returns the Operation result of an asynchronously invoked Operation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetOperationAsyncResult(ctx context.Context, submodelIdentifier string, idShortPath string, handleID string) (gen.ImplResponse, error) {
	// TODO - update GetOperationAsyncResult with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, OperationResult{}) or use other options such as http.Ok ...
	// return gen.Response(200, OperationResult{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("GetOperationAsyncResult method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "GetOperationAsyncResult", "NotImplemented"), nil
}

// GetOperationAsyncResultValueOnly - Returns the Operation result of an asynchronously invoked Operation
//
//nolint:revive
func (s *SubmodelRepositoryAPIAPIService) GetOperationAsyncResultValueOnly(ctx context.Context, submodelIdentifier string, idShortPath string, handleID string) (gen.ImplResponse, error) {
	// TODO - update GetOperationAsyncResultValueOnly with the required logic for this service method.
	// Add api_submodel_repository_api_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	// TODO: Uncomment the next line to return response Response(200, OperationResultValueOnly{}) or use other options such as http.Ok ...
	// return gen.Response(200, OperationResultValueOnly{}), nil

	// TODO: Uncomment the next line to return response Response(400, Result{}) or use other options such as http.Ok ...
	// return gen.Response(400, Result{}), nil

	// TODO: Uncomment the next line to return response Response(401, Result{}) or use other options such as http.Ok ...
	// return gen.Response(401, Result{}), nil

	// TODO: Uncomment the next line to return response Response(403, Result{}) or use other options such as http.Ok ...
	// return gen.Response(403, Result{}), nil

	// TODO: Uncomment the next line to return response Response(404, Result{}) or use other options such as http.Ok ...
	// return gen.Response(404, Result{}), nil

	// TODO: Uncomment the next line to return response Response(500, Result{}) or use other options such as http.Ok ...
	// return gen.Response(500, Result{}), nil

	// TODO: Uncomment the next line to return response Response(0, Result{}) or use other options such as http.Ok ...
	// return gen.Response(0, Result{}), nil

	notImplementedErr := errors.New("GetOperationAsyncResultValueOnly method not implemented")
	return newAPIErrorResponse(notImplementedErr, http.StatusNotImplemented, "GetOperationAsyncResultValueOnly", "NotImplemented"), nil
}

// QuerySubmodels returns all Submodels that match the input query.
// It supports filtering based on the query language and provides pagination through cursor-based navigation.
//
// Parameters:
//   - ctx: Request context for security and cancellation
//   - limit: Maximum number of submodels to return
//   - cursor: Pagination cursor for continuing from previous results
//   - query: Query object containing the filter condition
//
// Returns:
//   - gen.ImplResponse: Response containing paginated submodel results
//   - error: Error if the operation fails
func (s *SubmodelRepositoryAPIAPIService) QuerySubmodels(
	_ context.Context,
	limit int32,
	cursor string,
	query grammar.Query,
) (gen.ImplResponse, error) {
	queryWrapper := &grammar.QueryWrapper{
		Query: query,
	}

	sms, nextCursor, err := s.submodelBackend.QuerySubmodels(limit, cursor, queryWrapper, false)
	if err != nil {
		switch {
		case common.IsErrBadRequest(err):
			return common.NewErrorResponse(
				err, http.StatusBadRequest, "SMREPO", "QuerySubmodels", "BadRequest",
			), nil
		default:
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, "SMREPO", "QuerySubmodels", "InternalServerError",
			), err
		}
	}

	converted := make([]map[string]any, 0, len(sms))
	for _, sm := range sms {
		jsonable, convertErr := jsonization.ToJsonable(sm)
		if convertErr != nil {
			return common.NewErrorResponse(
				convertErr, http.StatusInternalServerError, "SMREPO", "QuerySubmodels", "InternalServerError",
			), convertErr
		}
		converted = append(converted, jsonable)
	}

	res := gen.GetSubmodelsResult{
		PagingMetadata: gen.PagedResultPagingMetadata{
			Cursor: nextCursor,
		},
		Result: converted,
	}

	return gen.Response(http.StatusOK, res), nil
}
