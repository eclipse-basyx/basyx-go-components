// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * DotAAS Part 2 | HTTP/REST | Asset Administration Shell Registry Service Specification
 *
 * The Query Profile of the Asset Administration Shell Registry Service Specification as part of the [Specification of the Asset Administration Shell: Part 2](https://industrialdigitaltwin.org/en/content-hub/aasspecifications).   Copyright: Industrial Digital Twin Association (IDTA) 2025
 *
 * API version: V3.1.0_SSP-004
 * Contact: info@idtwin.org
 */

package model

type LogicalExpression struct {
	And []LogicalExpression `json:"$and,omitempty"`

	Match []MatchExpression `json:"$match,omitempty"`

	Or []LogicalExpression `json:"$or,omitempty"`

	Not *LogicalExpression `json:"$not,omitempty"`

	Eq []Value `json:"$eq,omitempty"`

	Ne []Value `json:"$ne,omitempty"`

	Gt []Value `json:"$gt,omitempty"`

	Ge []Value `json:"$ge,omitempty"`

	Lt []Value `json:"$lt,omitempty"`

	Le []Value `json:"$le,omitempty"`

	Contains []StringValue `json:"$contains,omitempty"`

	StartsWith []StringValue `json:"$starts-with,omitempty"`

	EndsWith []StringValue `json:"$ends-with,omitempty"`

	Regex []StringValue `json:"$regex,omitempty"`

	Boolean bool `json:"$boolean,omitempty"`
}

// AssertLogicalExpressionRequired checks if the required fields are not zero-ed
func AssertLogicalExpressionRequired(obj LogicalExpression) error {
	for _, el := range obj.And {
		if err := AssertLogicalExpressionRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Match {
		if err := AssertMatchExpressionRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Or {
		if err := AssertLogicalExpressionRequired(el); err != nil {
			return err
		}
	}
	if obj.Not != nil {
		if err := AssertLogicalExpressionRequired(*obj.Not); err != nil {
			return err
		}
	}
	for _, el := range obj.Eq {
		if err := AssertValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Ne {
		if err := AssertValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Gt {
		if err := AssertValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Ge {
		if err := AssertValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Lt {
		if err := AssertValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Le {
		if err := AssertValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Contains {
		if err := AssertStringValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.StartsWith {
		if err := AssertStringValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.EndsWith {
		if err := AssertStringValueRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Regex {
		if err := AssertStringValueRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertLogicalExpressionConstraints checks if the values respects the defined constraints
func AssertLogicalExpressionConstraints(obj LogicalExpression) error {
	for _, el := range obj.And {
		if err := AssertLogicalExpressionConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Match {
		if err := AssertMatchExpressionConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Or {
		if err := AssertLogicalExpressionConstraints(el); err != nil {
			return err
		}
	}
	if obj.Not != nil {
		if err := AssertLogicalExpressionConstraints(*obj.Not); err != nil {
			return err
		}
	}
	for _, el := range obj.Eq {
		if err := AssertValueConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Ne {
		if err := AssertValueConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Gt {
		if err := AssertValueConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Ge {
		if err := AssertValueConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Lt {
		if err := AssertValueConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Le {
		if err := AssertValueConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Contains {
		if err := AssertStringValueConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.StartsWith {
		if err := AssertStringValueConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.EndsWith {
		if err := AssertStringValueConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Regex {
		if err := AssertStringValueConstraints(el); err != nil {
			return err
		}
	}
	return nil
}
