/*******************************************************************************
* Copyright (C) 2026 the Eclipse BaSyx Authors and Fraunhofer IESE
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
* SPDX-License-Identifier: MIT
******************************************************************************/
// Author: Martin Stemmer ( Fraunhofer IESE )

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
/*
 * DotAAS Part 2 | HTTP/REST | Submodel Registry Service Specification
 *
 * The Full Profile of the Submodel Registry Service Specification as part of the [Specification of the Asset Administration Shell: Part 2](https://industrialdigitaltwin.org/en/content-hub/aasspecifications).   Copyright: Industrial Digital Twin Association (IDTA) 2025
 *
 * API version: V3.1.1_SSP-001
 * Contact: info@idtwin.org
 */
package smregistryapi

import (
	"context"
	"errors"
	"log"
	"net/http"
	"strings"

	"github.com/eclipse-basyx/basyx-go-components/internal/common"
	"github.com/eclipse-basyx/basyx-go-components/internal/common/model"
	smregistrypostgresql "github.com/eclipse-basyx/basyx-go-components/internal/smregistry/persistence"
)

const (
	componentName = "SMR"
)

// SubmodelRegistryAPIAPIService is a service that implements the logic for the SubmodelRegistryAPIAPIServicer
// This service should implement the business logic for every endpoint for the SubmodelRegistryAPIAPI API.
// Include any external packages or services that will be required by this service.
type SubmodelRegistryAPIAPIService struct {
	smRegistryBackend smregistrypostgresql.PostgreSQLSMDatabase
}

// NewSubmodelRegistryAPIAPIService creates a default api service
func NewSubmodelRegistryAPIAPIService(databaseBackend smregistrypostgresql.PostgreSQLSMDatabase) *SubmodelRegistryAPIAPIService {
	return &SubmodelRegistryAPIAPIService{
		smRegistryBackend: databaseBackend,
	}
}

// GetAllSubmodelDescriptors - Returns all Submodel Descriptors
func (s *SubmodelRegistryAPIAPIService) GetAllSubmodelDescriptors(ctx context.Context, limit int32, cursor string) (model.ImplResponse, error) {
	internalCursor, resp, err := decodeCursor(strings.TrimSpace(cursor), "GetAllSubmodelDescriptors")
	if resp != nil || err != nil {
		return *resp, err
	}

	smds, nextCursor, err := s.smRegistryBackend.ListSubmodelDescriptors(ctx, limit, internalCursor)
	if err != nil {
		log.Printf("[ERROR] [%s] Error in GetAllSubmodelDescriptors: list failed (limit=%d cursor=%q): %v", componentName, limit, internalCursor, err)
		switch {
		case common.IsErrBadRequest(err):
			return common.NewErrorResponse(
				err, http.StatusBadRequest, componentName, "GetAllSubmodelDescriptors", "BadRequest",
			), nil
		default:
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "GetAllSubmodelDescriptors", "InternalServerError",
			), err
		}
	}

	jsonable := make([]map[string]any, 0, len(smds))
	for _, smd := range smds {
		j, toJsonErr := smd.ToJsonable()
		if toJsonErr != nil {
			log.Printf("[ERROR] [%s] Error in GetAllSubmodelDescriptors: ToJsonable failed (submodelId=%q): %v", componentName, smd.Id, toJsonErr)
			return common.NewErrorResponse(
				toJsonErr, http.StatusInternalServerError, componentName, "GetAllSubmodelDescriptors", "Unhandled-ToJsonable",
			), toJsonErr
		}
		jsonable = append(jsonable, j)
	}

	return pagedResponse(jsonable, nextCursor), nil
}

// PostSubmodelDescriptor - Creates a new Submodel Descriptor, i.e. registers a submodel
func (s *SubmodelRegistryAPIAPIService) PostSubmodelDescriptor(ctx context.Context, submodelDescriptor model.SubmodelDescriptor) (model.ImplResponse, error) {
	if strings.TrimSpace(submodelDescriptor.Id) != "" {
		if exists, chkErr := s.smRegistryBackend.ExistsSubmodelByID(ctx, submodelDescriptor.Id); chkErr != nil {
			log.Printf("[ERROR] [%s] Error in PostSubmodelDescriptor: existence check failed (submodelId=%q): %v", componentName, submodelDescriptor.Id, chkErr)
			return common.NewErrorResponse(
				chkErr, http.StatusInternalServerError, componentName, "PostSubmodelDescriptor", "Unhandled-Precheck",
			), chkErr
		} else if exists {
			e := common.NewErrConflict("Submodel with given id already exists")
			log.Printf("[ERROR] [%s] Error in PostSubmodelDescriptor: conflict (submodelId=%q): %v", componentName, submodelDescriptor.Id, e)
			return common.NewErrorResponse(
				e, http.StatusConflict, componentName, "PostSubmodelDescriptor", "Conflict-Exists",
			), nil
		}
	}

	result, err := s.smRegistryBackend.InsertSubmodelDescriptor(ctx, submodelDescriptor)
	if err != nil {
		switch {
		case common.IsErrBadRequest(err):
			log.Printf("[ERROR] [%s] Error in InsertSubmodelDescriptor: bad request (submodelId=%q): %v", componentName, submodelDescriptor.Id, err)
			return common.NewErrorResponse(
				err, http.StatusBadRequest, componentName, "InsertSubmodelDescriptor", "BadRequest",
			), nil
		case common.IsErrConflict(err):
			log.Printf("[ERROR] [%s] Error in InsertSubmodelDescriptor: conflict (submodelId=%q): %v", componentName, submodelDescriptor.Id, err)
			return common.NewErrorResponse(
				err, http.StatusConflict, componentName, "InsertSubmodelDescriptor", "Conflict",
			), nil
		case common.IsErrDenied(err):
			log.Printf("[ERROR] [%s] Error in InsertSubmodelDescriptor: denied (submodelId=%q): %v", componentName, submodelDescriptor.Id, err)
			return common.NewErrorResponse(
				err, http.StatusForbidden, componentName, "InsertSubmodelDescriptor", "Denied",
			), nil
		default:
			log.Printf("[ERROR] [%s] Error in InsertSubmodelDescriptor: internal (submodelId=%q): %v", componentName, submodelDescriptor.Id, err)
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "InsertSubmodelDescriptor", "Unhandled",
			), err
		}
	}

	j, toJsonErr := result.ToJsonable()
	if toJsonErr != nil {
		log.Printf("[ERROR] [%s] Error in PostSubmodelDescriptor: ToJsonable failed (submodelId=%q): %v", componentName, result.Id, toJsonErr)
		return common.NewErrorResponse(
			toJsonErr, http.StatusInternalServerError, componentName, "PostSubmodelDescriptor", "Unhandled-ToJsonable",
		), toJsonErr
	}

	return model.Response(http.StatusCreated, j), nil
}

// GetSubmodelDescriptorById - Returns a specific Submodel Descriptor
func (s *SubmodelRegistryAPIAPIService) GetSubmodelDescriptorById(ctx context.Context, submodelIdentifier string) (model.ImplResponse, error) {
	decoded, resp, err := decodePathParam(submodelIdentifier, "submodelIdentifier", "GetSubmodelDescriptorById", "BadRequest-Decode")
	if resp != nil || err != nil {
		return *resp, err
	}

	result, err := s.smRegistryBackend.GetSubmodelDescriptorByID(ctx, decoded)
	if err != nil {
		switch {
		case common.IsErrBadRequest(err):
			log.Printf("[ERROR] [%s] Error in GetSubmodelDescriptorById: bad request (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusBadRequest, componentName, "GetSubmodelDescriptorById", "BadRequest",
			), nil
		case common.IsErrNotFound(err):
			log.Printf("[ERROR] [%s] Error in GetSubmodelDescriptorById: not found (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusNotFound, componentName, "GetSubmodelDescriptorById", "NotFound",
			), nil
		default:
			log.Printf("[ERROR] [%s] Error in GetSubmodelDescriptorById: internal (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "GetSubmodelDescriptorById", "Unhandled",
			), err
		}
	}

	jsonable, toJsonErr := result.ToJsonable()
	if toJsonErr != nil {
		return common.NewErrorResponse(
			toJsonErr, http.StatusInternalServerError, componentName, "GetSubmodelDescriptorById", "Unhandled-ToJsonable",
		), toJsonErr
	}

	return model.Response(http.StatusOK, jsonable), nil
}

// PutSubmodelDescriptorById - Creates or updates an existing Submodel Descriptor
func (s *SubmodelRegistryAPIAPIService) PutSubmodelDescriptorById(ctx context.Context, submodelIdentifier string, submodelDescriptor model.SubmodelDescriptor) (model.ImplResponse, error) {
	decoded, resp, err := decodePathParam(submodelIdentifier, "submodelIdentifier", "PutSubmodelDescriptorById", "BadRequest-Decode")
	if resp != nil || err != nil {
		return *resp, err
	}

	if strings.TrimSpace(submodelDescriptor.Id) != "" && submodelDescriptor.Id != decoded {
		log.Printf("[ERROR] [%s] Error in PutSubmodelDescriptorById: body id does not match path id (body=%q path=%q)", componentName, submodelDescriptor.Id, decoded)
		return common.NewErrorResponse(
			errors.New("body id does not match path id"), http.StatusBadRequest, componentName, "PutSubmodelDescriptorById", "BadRequest-IdMismatch",
		), nil
	}
	submodelDescriptor.Id = decoded

	if exists, chkErr := s.smRegistryBackend.ExistsSubmodelByID(ctx, submodelDescriptor.Id); chkErr != nil {
		log.Printf("[ERROR] [%s] Error in PutSubmodelDescriptorById: existence check failed (submodelId=%q): %v", componentName, submodelDescriptor.Id, chkErr)
		return common.NewErrorResponse(
			chkErr, http.StatusInternalServerError, componentName, "PutSubmodelDescriptorById", "Unhandled-Precheck",
		), chkErr
	} else if !exists {
		result, err := s.smRegistryBackend.InsertSubmodelDescriptor(ctx, submodelDescriptor)
		if err != nil {
			switch {
			case common.IsErrBadRequest(err):
				log.Printf("[ERROR] [%s] Error in InsertSubmodelDescriptor: bad request (submodelId=%q): %v", componentName, submodelDescriptor.Id, err)
				return common.NewErrorResponse(
					err, http.StatusBadRequest, componentName, "InsertSubmodelDescriptor", "BadRequest",
				), nil
			case common.IsErrConflict(err):
				log.Printf("[ERROR] [%s] Error in InsertSubmodelDescriptor: conflict (submodelId=%q): %v", componentName, submodelDescriptor.Id, err)
				return common.NewErrorResponse(
					err, http.StatusConflict, componentName, "InsertSubmodelDescriptor", "Conflict",
				), nil
			case common.IsErrDenied(err):
				log.Printf("[ERROR] [%s] Error in InsertSubmodelDescriptor: denied (submodelId=%q): %v", componentName, submodelDescriptor.Id, err)
				return common.NewErrorResponse(
					err, http.StatusForbidden, componentName, "InsertSubmodelDescriptor", "Denied",
				), nil
			default:
				log.Printf("[ERROR] [%s] Error in InsertSubmodelDescriptor: internal (submodelId=%q): %v", componentName, submodelDescriptor.Id, err)
				return common.NewErrorResponse(
					err, http.StatusInternalServerError, componentName, "InsertSubmodelDescriptor", "Unhandled",
				), err
			}
		}
		j, toJsonErr := result.ToJsonable()
		if toJsonErr != nil {
			log.Printf("[ERROR] [%s] Error in PutSubmodelDescriptorById: ToJsonable failed (submodelId=%q): %v", componentName, result.Id, toJsonErr)
			return common.NewErrorResponse(
				toJsonErr, http.StatusInternalServerError, componentName, "PutSubmodelDescriptorById", "Unhandled-ToJsonable",
			), toJsonErr
		}
		return model.Response(http.StatusCreated, j), nil
	}

	_, err = s.smRegistryBackend.ReplaceSubmodelDescriptor(ctx, submodelDescriptor)
	if err != nil {
		switch {
		case common.IsErrBadRequest(err):
			log.Printf("[ERROR] [%s] Error in PutSubmodelDescriptorById: bad request (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusBadRequest, componentName, "PutSubmodelDescriptorById", "BadRequest",
			), nil
		case common.IsErrConflict(err):
			log.Printf("[ERROR] [%s] Error in PutSubmodelDescriptorById: conflict (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusConflict, componentName, "PutSubmodelDescriptorById", "Conflict",
			), nil
		case common.IsErrDenied(err):
			log.Printf("[ERROR] [%s] Error in PutSubmodelDescriptorById: denied (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusForbidden, componentName, "PutSubmodelDescriptorById", "Denied",
			), nil
		case common.IsErrNotFound(err):
			log.Printf("[ERROR] [%s] Error in PutSubmodelDescriptorById: not found (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusNotFound, componentName, "PutSubmodelDescriptorById", "NotFound",
			), nil
		default:
			log.Printf("[ERROR] [%s] Error in PutSubmodelDescriptorById: internal (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "PutSubmodelDescriptorById", "Unhandled-Replace",
			), err
		}
	}

	return model.Response(http.StatusNoContent, nil), nil
}

// DeleteSubmodelDescriptorById - Deletes a Submodel Descriptor, i.e. de-registers a submodel
func (s *SubmodelRegistryAPIAPIService) DeleteSubmodelDescriptorById(ctx context.Context, submodelIdentifier string) (model.ImplResponse, error) {
	decoded, resp, err := decodePathParam(submodelIdentifier, "submodelIdentifier", "DeleteSubmodelDescriptorById", "BadRequest-Decode")
	if resp != nil || err != nil {
		return *resp, err
	}

	if err := s.smRegistryBackend.DeleteSubmodelDescriptorByID(ctx, decoded); err != nil {
		switch {
		case common.IsErrNotFound(err):
			log.Printf("[ERROR] [%s] Error in DeleteSubmodelDescriptorById: not found (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusNotFound, componentName, "DeleteSubmodelDescriptorById", "NotFound",
			), nil
		case common.IsErrDenied(err):
			log.Printf("[ERROR] [%s] Error in DeleteSubmodelDescriptorById: denied (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusForbidden, componentName, "DeleteSubmodelDescriptorById", "Denied",
			), nil
		case common.IsErrBadRequest(err):
			log.Printf("[ERROR] [%s] Error in DeleteSubmodelDescriptorById: bad request (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusBadRequest, componentName, "DeleteSubmodelDescriptorById", "BadRequest",
			), nil
		default:
			log.Printf("[ERROR] [%s] Error in DeleteSubmodelDescriptorById: internal (submodelId=%q): %v", componentName, decoded, err)
			return common.NewErrorResponse(
				err, http.StatusInternalServerError, componentName, "DeleteSubmodelDescriptorById", "Unhandled",
			), err
		}
	}

	return model.Response(http.StatusNoContent, nil), nil
}
