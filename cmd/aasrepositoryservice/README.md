# AAS Repository API – Developer Setup & Template

This document explains how the **AAS Repository** API in `basyx-go-components` is structured and how to set up a **new repository service** (e.g. another `XRepository`) using the same pattern.

The key ideas:

- OpenAPI spec → chi-based Go server stubs
- Autogenerated code lives in `pkg/<component>api/go`
- Real business logic lives in `internal/<component>/api`
- Service entrypoint lives in `cmd/<component>service`
- Shared DTOs come from `internal/common/model`, not from generated `model_*.go`

---

## 1. Prerequisites

- Go (version defined in the repo `go.mod`)
- Node.js + npm
- Git access to this repository

Clone the repo:

```bash
git clone git@github.com:eclipse-basyx/basyx-go-components.git
cd basyx-go-components

---
## 2. Architecture Overview

Each repository-like service (Submodel Repository, AAS Repository, etc.) follows this pattern:

pkg/<component>api/go
Autogenerated OpenAPI server stubs (chi router, handler interfaces, DTO types).

internal/<component>/api
Hand-written implementation of the generated interfaces.

cmd/<component>service
Main entrypoint: loads config, creates router, starts HTTP server.

For the AAS Repository, these are:

pkg/aasrepositoryapi/go

internal/aasrepository/api

cmd/aasrepositoryservice

## 3. Generating the AAS Repository API (OpenAPI → Go)

The AAS API is defined by an OpenAPI spec, e.g.:

aas-repository-api.yaml


We generate chi-based Go server stubs using go-server:

npx @openapitools/openapi-generator-cli generate \
  -g go-server \
  -i aas-repository-api.yaml \
  -o regen-temp \
  --skip-validate-spec \
  --additional-properties=packageName=openapi,isGoSubmodule=true,enumClassPrefix=true,router=chi


This will create a regen-temp folder with (among other files):

api.go

api_asset_administration_shell_repository_api.go

api_asset_administration_shell_repository_api_service.go

api_description_api.go

api_description_api_service.go

api_serialization_api.go

api_serialization_api_service.go

routers.go

impl.go

logger.go

error.go

helpers.go

A lot of model_*.go and docs/*.md files

We do not commit everything. We only keep the core server files.

## 4. Folder Layout for AAS Repository

Final code layout for the AAS Repository:

basyx-go-components/
  cmd/
    aasrepositoryservice/
      main.go
      ... (config, healthcheck, etc.)
  internal/
    aasrepository/
      api/
        ... (service implementation)
    common/
      model/
        ... (shared DTOs)
  pkg/
    aasrepositoryapi/
      go/
        api.go
        api_asset_administration_shell_repository_api.go
        api_asset_administration_shell_repository_api_service.go
        api_description_api.go
        api_description_api_service.go
        api_serialization_api.go
        api_serialization_api_service.go
        routers.go
        impl.go
        logger.go
        error.go
        helpers.go


All generated code for this API lives in pkg/aasrepositoryapi/go.

## 5. Customizing the Generated Code
### 5.1. Copy core .go files

From regen-temp, copy only the core Go files into:

pkg/aasrepositoryapi/go

Delete the following from the component package:

All model_*.go files

All docs/*.md

Any client.go, configuration.go, response.go, utils.go (those belong to -g go, not -g go-server)

### 5.2. Use shared model types (type aliases in api.go)

The project defines shared DTOs in:

internal/common/model


Instead of keeping OpenAPI-specific model_*.go, we alias the generated types to these shared models.

In pkg/aasrepositoryapi/go/api.go:

Import the shared model package:

import (
    "context"
    "net/http"
    "os"

    model "github.com/eclipse-basyx/basyx-go-components/internal/common/model"
)


Add type aliases:

type (
    AssetAdministrationShell  = model.AssetAdministrationShell
    AssetInformation          = model.AssetInformation
    Reference                 = model.Reference
    Submodel                  = model.Submodel
    SubmodelMetadata          = model.SubmodelMetadata
    SubmodelElement           = model.SubmodelElement
    SubmodelElementMetadata   = model.SubmodelElementMetadata
    SubmodelElementValue      = model.SubmodelElementValue
    OperationRequest          = model.OperationRequest
    OperationRequestValueOnly = model.OperationRequestValueOnly
)


This allows the generated handlers to use AssetAdministrationShell etc., but the actual definitions are in internal/common/model.

### 5.3. chi router configuration (no gorilla/mux)

routers.go uses chi as the HTTP router (because of router=chi):

import (
    "encoding/json"
    "errors"
    "time"
    "net/http"

    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
)


Router setup:

func NewRouter(routers ...Router) chi.Router {
    router := chi.NewRouter()
    router.Use(middleware.Logger)

    for _, api := range routers {
        for _, route := range api.Routes() {
            var handler http.Handler = route.HandlerFunc
            router.Method(route.Method, route.Pattern, handler)
        }
    }
    return router
}


Path parameters in the controllers (e.g. api_asset_administration_shell_repository_api.go) use chi:

aasIdentifierParam := chi.URLParam(r, "aasIdentifier")

### 5.4. Validation stubs in helpers.go

The generated controllers may call validation helpers like:

AssertSubmodelMetadataRequired(...)
AssertSubmodelMetadataConstraints(...)
AssertSubmodelElementMetadataRequired(...)
AssertOperationRequestRequired(...)
...


Since we deleted model_*.go (and their validation code), we provide simple no-op stubs in helpers.go:

func AssertSubmodelMetadataRequired(obj interface{}) error    { return nil }
func AssertSubmodelMetadataConstraints(obj interface{}) error { return nil }

func AssertSubmodelElementMetadataRequired(obj interface{}) error    { return nil }
func AssertSubmodelElementMetadataConstraints(obj interface{}) error { return nil }

func AssertSubmodelElementValueRequired(obj interface{}) error    { return nil }
func AssertSubmodelElementValueConstraints(obj interface{}) error { return nil }

func AssertOperationRequestRequired(obj interface{}) error    { return nil }
func AssertOperationRequestConstraints(obj interface{}) error { return nil }

func AssertOperationRequestValueOnlyRequired(obj interface{}) error    { return nil }
func AssertOperationRequestValueOnlyConstraints(obj interface{}) error { return nil }


These keep compilation working with shared models and without OpenAPI-specific validation logic.

## 6. Wiring the Service
### 6.1. Main entrypoint (cmd/aasrepositoryservice/main.go)

The main typically does:

Load configuration (env / YAML).

Setup DB connections, logging, etc.

Create the implementation of the service.

Wrap it with the generated API.

Build the chi router and start the HTTP server.

Example structure:

package main

import (
    "fmt"
    "log"
    "net/http"

    aasapi "github.com/eclipse-basyx/basyx-go-components/pkg/aasrepositoryapi/go"
    internalapi "github.com/eclipse-basyx/basyx-go-components/internal/aasrepository/api"
)

func main() {
    // 1. Load config (omitted here for brevity)
    cfg := loadConfig()

    // 2. Init dependencies (DB, logger, etc.)
    deps := initDeps(cfg)

    // 3. Create service implementation (internal)
    impl := internalapi.NewAasRepositoryService(deps)

    // 4. Create generated API wrapper
    api := aasapi.NewAssetAdministrationShellRepositoryAPI(impl)

    // 5. Build chi router using generated router
    router := aasapi.NewRouter(api)

    addr := fmt.Sprintf(":%d", cfg.Server.Port)
    log.Printf("AAS Repository listening on %s", addr)

    if err := http.ListenAndServe(addr, router); err != nil {
        log.Fatalf("Server error: %v", err)
    }
}

### 6.2. Internal implementation (internal/aasrepository/api)

This package contains the concrete implementation of the generated ...Servicer interfaces.

Example sketch:

package api

import (
    openapi "github.com/eclipse-basyx/basyx-go-components/pkg/aasrepositoryapi/go"
)

type AasRepositoryService struct {
    // DB, logger, config, etc.
}

func NewAasRepositoryService(deps Dependencies) *AasRepositoryService {
    return &AasRepositoryService{
        // initialize fields from deps
    }
}

// Implements openapi.AssetAdministrationShellRepositoryAPIServicer
func (s *AasRepositoryService) GetAllAssetAdministrationShells(/* params */) (openapi.ImplResponse, error) {
    // business logic here
    // return openapi.Response(http.StatusOK, data), nil
}

## 7. Creating Another Repository API Following This Pattern

If you want to add a new repository-like service (e.g. myrepository):

Create or obtain an OpenAPI spec, e.g. my-repository-api.yaml.

Generate chi-based server stubs:

npx @openapitools/openapi-generator-cli generate \
  -g go-server \
  -i my-repository-api.yaml \
  -o regen-temp \
  --skip-validate-spec \
  --additional-properties=packageName=openapi,isGoSubmodule=true,enumClassPrefix=true,router=chi


Create the target package:

pkg/myrepositoryapi/go


Copy core .go files from regen-temp to pkg/myrepositoryapi/go (same pattern as AAS).

Delete unwanted generated artifacts:

model_*.go

docs/*.md

client-related files (client.go, configuration.go, etc.)

Alias types in pkg/myrepositoryapi/go/api.go to shared models in internal/common/model if appropriate.

Add validation stubs in helpers.go if the generated code refers to Assert* functions that no longer exist.

Create internal implementation:

internal/myrepository/api


Implement ...Servicer interfaces from api_..._service.go.

Create service entrypoint:

cmd/myrepositoryservice


Follow the same structure as cmd/aasrepositoryservice.

Run locally:

cd cmd/myrepositoryservice
go run .

## 8. Quickstart for New Developers (AAS Repository)

For a new developer who just wants to run the AAS Repository service:

git clone git@github.com:eclipse-basyx/basyx-go-components.git
cd basyx-go-components

# Optional: configure DB and environment variables if needed

cd cmd/aasrepositoryservice
go run .


The service will start and listen on the configured port (default is often 5004), using:

chi router

OpenAPI-generated server stubs in pkg/aasrepositoryapi/go

implementations in internal/aasrepository/api
